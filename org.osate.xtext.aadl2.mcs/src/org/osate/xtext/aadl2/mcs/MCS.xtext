grammar org.osate.xtext.aadl2.mcs.MCS with org.osate.xtext.aadl2.properties.Properties
//org.osate.xtext.aadl2.Aadl2
generate mcs "http://www.osate.org/xtext/aadl2/mcs/MCS"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.osate.aadl2/model/aadl2.ecore" as aadl2
//import "http://www.eclipse.org/xtext/xbase/Xbase"

MCSGrammarRoot :    
        'annex' lib = MCSAnnexLibrary 
        | 'mcs' file = MCSFileLibrary
        | 'subclause' subclause = MCSAnnexSubclause
;

AnnexLibrary returns aadl2::AnnexLibrary:
     MCSAnnexLibrary
;

AnnexSubclause returns aadl2::AnnexSubclause:
     MCSAnnexSubclause
;


MCSAnnexLibrary returns MCSAnnexLibrary:
	 {MCSAnnexLibrary}
	  ('types' (types += Type_declaration)+)?
	  ('constants' (constants += Constant_declaration)+)?
	  ('functions' (functions += Function_declaration)+)?
	  ('theorems' (theorems += Theorem_declaration)+)?
;
 
MCSFileLibrary:
	{MCSFileLibrary} 
	  ('with' (importedUnit+=[aadl2::ModelUnit])  
	                     (',' importedUnit+=[aadl2::ModelUnit])*)+
	  ('import' (files += File_name) (',' files += File_name)*)*
	  ('types' (types += Type_declaration)+)?
	  ('constants' (constants += Constant_declaration)+)?
	  ('functions' (functions += Function_declaration)+)?
	  ('theorems' (theorems += Theorem_declaration)+)?
	  ('constraints' (calls += Theorem_call)+)?
;

MCSAnnexSubclause returns MCSAnnexSubclause:       
	 {MCSAnnexSubclause}
	(  (calls += Theorem_call)+)?
;

File_name:
	STRING
;

Type_declaration:
   'type' name=ID  '=' type = Type_expression ';'	
;

Constant_declaration :
   ('const')? const = McsTypedName '='  left_expr = Expr ';' 
 
;

Function_declaration returns Function:
	name=ID => '(' (args+=Parameter (',' args+=Parameter)*)? ')' body=FunctionBody
;

Theorem_declaration returns Theorem:
	name=ID (t_root ?= Theorem_root)? => '(' (args+=Parameter (',' args+=Parameter)*)? ')' body=TheoremBody
;
/* 
F_or_T_declaration returns FuncOrTheorem:
	name=ID (t_root ?= Theorem_root)? '(' (args+=Parameter (',' args+=Parameter)*)? ')' body=DefinitionBody
;
*/	
Theorem_root:
	'<' 'root' ':' ( nilroot ?= 'nil' | classifier = Classifiers) '>'
;

FunctionBody:
	{FunctionBody} ':' type=Type_expression '=' expr=Expr
;

TheoremBody:
	{TheoremBody} '<='  (string += ParameterizedString)+ expr=Expr
;
/* 
DefinitionBody:
	{FunctionBody} ':' type=Type_expression '=' expr=Expr
  | {ClaimBody} '<='  (string += ParameterizedString)+ expr=Expr
;
*/
ParameterizedString:
	('**'(claim+=TextParm)+'**')
;

//Arg types are used for functions, claims, and quantifiers

Parameter: 
	McsTypedName
;

TextParm:
	 {ClaimString} str=StringTerm 
| 	 {ClaimArg} textarg=MCSNameExpr ('%' unit=[aadl2::UnitLiteral])?
;

McsName:
	name=ID
;

McsTypedName: 
   name=ID (':' type=Type_expression | 'in' expr = Expr) 
;

Domain:
	name=ID 'in' expr=Expr					// must be a set expression
;

Theorem_call returns TheoremCall:
    ('check'|'prove') tname = [Theorem]                   // must be a theorem reference 
           ('<' ('nil'| croot = Classifier_literal) '>')?
             '(' (actarg += Expr ( ',' actarg += Expr)*)? ')'
;

Classifier_literal:
	-> classlit = [aadl2::ComponentClassifier| FQCREF] 
	| nameref = Mcs_name_ref //[ClaimTextVar] //
;

RealTerm returns aadl2::RealLiteral:
	value=UnsignedReal (unit=[aadl2::UnitLiteral|ID])?
;

UnsignedReal returns aadl2::Real:
	REAL_LIT
;

IntegerTerm returns aadl2::IntegerLiteral:
	value=UnsignedInt (unit=[aadl2::UnitLiteral|ID])?
;

UnsignedInt returns aadl2::Integer:
	INTEGER_LIT
;

Range: 
	lowerBound=(IntegerTerm | RealTerm) 
	 '..' upperBound=(IntegerTerm |RealTerm)   
	;

RefTerm returns RefTerm:
  'reference' '(' 	(root ?= 'root' '.')?
  sub=NestedDotID //ContainmentPath
  ')'
  ;

NestedDotID:
	base=[aadl2::NamedElement | ID] ('.' sub=NestedDotID)?
;

Mcs_name_ref:           
	ref = [McsTypedName]  ->(chain = MethodChain)?
;
MethodChain:
	{MethodChain} -> ('.' ( builtin+= BuiltInFnCall | method+= FnCall))*
;
BuiltInFnCall :
	fn=BuiltInFn '(' (args+=Expr (',' args+=Expr)*)?  ')'
;

FnCall:
	fn=[Function] '(' (args+=Expr (',' args+=Expr)*)? ')'
;
/* 
PropertyExists:
  ('has_property' | '#?') '(' property=[aadl2::Property|QPREF]
						(',' modeset = Expr (',' inbind = Expr)?)?
				   ')'
;
PropertyVal:
	('property' | '#') '(' property=[aadl2::Property|QPREF]
						(',' modeset = Expr (',' inbind = Expr)?)?
				')'
;


LetBinding :
	local = McsTypedName '=' expr=Expr
;

*/

Expr:
	FailExpr  
;

FailExpr returns Expr:
	ImpliesExpr (=>({BinaryExpr.left=current} op='fail') right=ParameterizedString)?
;

ImpliesExpr returns Expr:
	OrExpr (=>({BinaryExpr.left=current} op='=>') right=ImpliesExpr)?
;

OrExpr returns Expr:
	AndExpr (=>({BinaryExpr.left=current} op='or') right=AndExpr)*
;

AndExpr returns Expr:
	InstanceOfExpr (=>({BinaryExpr.left=current} (op='and'|op='andthen')) right=InstanceOfExpr)*
;

InstanceOfExpr returns Expr:
	RelationalExpr (=>({InstanceOfExpr.expr=current} 'instanceof') type=Type_expression)?
;

RelationalOp:
	'<' | '<=' | '>' | '>=' | '=' | '<>'
;
 
RelationalExpr returns Expr:
	PlusExpr (=>({BinaryExpr.left=current} op=RelationalOp) right=PlusExpr)?
;

PlusExpr returns Expr:
	TimesExpr (=>({BinaryExpr.left=current} op=('+' | '-')) right=TimesExpr)*
;

TimesExpr returns Expr:
	PrefixExpr (=>({BinaryExpr.left=current} op=('*' | '/' | '%')) right=PrefixExpr)*	
;

PrefixExpr returns Expr:
	{UnaryExpr} op = ('-' | 'not') expr=PrefixExpr 
//|   {PreCastExpr} '(' type=Type_expression ')' expr=PrefixExpr
|	PostCastExpr						  
;

PostCastExpr:
	{PostCastExpr} expr = Expression_term 
			->(chain = MethodChain)?
			=> ( '<' newtype = Type_expression '>')?
;

MCSNameExpr:
	{MCSNameExpr} (root ?= 'root' | iroot ?='iroot' |   nil ?= 'nil' 
| 	empty ?= 'empty'	| allmodes ?= 'allmodes' | => typednameref = Mcs_name_ref )
;

Expression_term returns Expr:
	
     MCSNameExpr
|	{PkgExpr} 'package' '(' package = [aadl2::AadlPackage] ')'
|   {CompExpr} classifier = ComponentClassifierTerm   // rules identical to
|   {RefExpr} reference = RefTerm			          // Properties.xtext expressions
|	{ThisExpr} 'this' ('.' sub = NestedDotID)? // from Properties grammar
|	{IntExpr} val=IntegerTerm
|   {RealExpr} val=RealTerm
|	{BoolExpr} val=BooleanLiteral
|   {StringExpr} val=StringTerm
|	{Range} val=Range       		// Int and Real Range from AADL.xtext
|	{IfThenElseExpr} 'if' cond=Expr 'then' then=Expr 'else' else=Expr
|   {QuantifiedExpr} quant=( 'forall' | 'foreach' | 'exists') 
								('(' args+= (Parameter/*|Domain*/) ')')+ '.' expr=Expr
|   {BuiltInFnCallExpr} builtin=BuiltInFnCall	
|	{FnCallExpr} fn=FnCall
|   {TheoremCallExpr} fn=Theorem_call
								  
|   {FilterSet} (list?='list')? '{' exp=Expr ( ({FilterMapExpr.map=current} 
						           'for' ('(' args+=(Parameter/*|Domain*/) ')')+ 
						          	 ('|' filter=Expr)?)
             		      	   | ({SetExpr.exprs+=current} (',' exprs+=Expr)*)) '}'
|	{MappingExpr} '[' expr1=Expr ',' expr2=Expr ']'
|   {EmptySetExpr} '{' '}'
|   {LetExpr} 'let' local = McsTypedName '=' expr1=Expr ';' expr2=Expr
|	'(' Expr ')'  
;

BuiltInFn:
// real primary type methods
	'has_range'| 'range'| 'floor' | 'ceiling'
// integer and real primary type 
|	'has_units' | 'unit_literal'
// range of integer, real primary type 
|	'upper' | 'lower' | 'has_delta' | 'delta'
// string primary type 
|	'concat' | 'eq' | 'less' | 'case_eq' | 'case_less'| 'in'
// set methods
| 	'union' | 'intersect' 
// set and list methods 
|	'has_member' |	'size' | 'sum' | 'max' | 'min'
// list methods
|	'get' | 'sublist' | 'join' | 'as_set'
// mapping methods
|	'key' | 'val'
// T_Element methods
|	'qualified_name' | 'local_name' | 'path_name_of' | 'package_name'
|	'is_owned_by' | 'has_parent' | 'parent' | 'owner' | 'equal' | 'element_type'
|	'has_property' | '#?' | 'property' | '#'
// T_Package methods
|	'imports' | 'classifiers'
// T_Classifier methods
|	'has_extends' | 'extends' | 'category'
// T_Classifier and I_Component methods
| 'has_bindings' | 'bindings_map' 
//	C_Impl methods
|	'component_type' | 'is_of_type'
//	C_Feature_Group methods
|	'has_inverse' | 'inverse'
//	T_Instance methods
|	'contaned' | 'in_modes'
//	I_Component methods
|	'is_prototype_ref' | 'prototype' | 'is_c_type_instance' | 'c_type'
|	'class'  // duplicate names | 'has_bindings' | 'bindings_map'
|	'array_cardinal' | 'modes' | 'modes_map' | 'mode_state_machine' 
|	'mode_transitions' | 'subcomponents' | 'instances'
// 	I_Component, I_Feature and I_Call_Sequence methods
|	'features' | 'flat_features' 
// 	I_Component and I_Call_Sequence methods
| 'connections'
//	I_Subprogram_Call methods
|	'call_target'
//	I_Connection methods
|	'is_bidirectional' | 'source' | 'destination'
//	I_Feature, I_Flow_Spec I_End_To_End methods
|	'is_refined' 
//	I_Feature methods
| 'is_partial' | 'has_prototype_ref' // % duplicate | 'prototype' | 'array_cardinal'
|	'has_classifier_type' | 'classifier_type' | 'direction' 
//	I_Feature group methods
| 'is_inverse'  // duplicate | 'has_bindings' | 'bindings_map' |	'features' | 'flat_features' 
//	I_Flow_Spec, I_Flow_Impl methods
|	'feature'  //duplicate | 'is_refined'
//	I_Flow_Impl,I_End_To_End_Flow methods
|	'path'  //duplicate for I_Flow_Impl | 'feature' 
//	I_End_To_End_Flow methods
|   'transitive_path' //duplicate |	'is_refined' | 'path' 
//	I_Prototype methods
|	'is_component_prototype' | 'type_literal' | 'has_list' | 'is_feature_prototype'
|	'is_fg_prototype' | 'has_classifier_reference' | 'classifier_reference'
//	I_Mode methods
|	'is_initial_mode' | 'is_required_mode' | 'mapped_set'
//	I_Mode_Transition methods
| 	'is_named' | 'transition_name' | 'transition_triggers'
|	'start_mode_state' | 'end_mode_state'
;

// Type rules

Type_expression: 				
	 basic = Basic_type |
	 composite = Composite_type |
	 element = Element_type
;
 
 // basic types rules
 
Basic_type:
   {Basic_type}(
	 ptype = 'property_type' | 
	 pref = 'property_ref' | 
	 bool = UnnamedBooleanType |		// from core AADL, shortcuts supported
	 string = UnnamedStringType | 
	 enumer = UnnamedEnumerationType |
	 units = UnnamedUnitsType |
 	 integer = UnnamedIntegerType |
	 real = UnnamedRealType |
	 range= UnnamedRangeType |  
	 typename = [Type_declaration]        // must be a user defined type
   )
;

// composite type rules

Composite_type :
		Mapping_type |
		Set_type |
		List_type |
		Record_type |
		Union_type
;

Mapping_type:
	'[' key=Type_expression 'to' val=Type_expression ']'
;

Set_type:
	'{' root_type=Type_expression '}'
|	'set' '<' root_type=Type_expression '>'
;

List_type:
	'(' root_type=Type_expression ')'
|	'list' '<' root_type=Type_expression '>'
;

Record_type:
	'record'  '( '( field += Id_type_pair)+ ')'
;

Union_type:
	'union' '('  types += Type_expression (','type += Type_expression )* ')'
;

Id_type_pair : 
	 name=ID ':' type = Type_expression
;

EnumerationLiteral returns aadl2::EnumerationLiteral:
	name=STRING;

//element type rules

Element_type : 
	telem ?= 'T_Element' 
|	tpack ?= 'T_Package'		
|	t_class ?= Classifiers 
|	t_inst ?= Instances
;

Classifiers:
	t_class ?='T_Classifier' 				
|	t_class_subtype ?= T_classifier_subtypes	
;

T_classifier_subtypes:
	t_ctype ?='C_Type'  
|	t_cimpl ?='C_Impl' 
|	t_fgclass ?= 'C_Feature_Group'  
|	t_annexclass ?= 'C_Annex'	
;

Instances:
	inst ?= 'T_Instance' |  t_inst_st ?= t_instance_subtypes	
;
 
t_instance_subtypes:
	t_subc_st ?= t_subcomponent_subtypes   
|	t_connection_subtypes  
|	t_feature_subtypes  
|	t_flow_spec_subtypes | t_flow_impl_subtypes  
|	t_sbcall ?= 'I_Subprogram_Call'  
|	t_callseq ?= 'I_Call_Sequence' 
|	t_eeflow ?= 'I_End_To_End_Flow' 
|	t_proto ?= 'I_Prototype' 
|	t_mode ?= 'I_Mode'  
|	t_mod_trans ?= 'I_Mode_Transition' 
| 	t_mode_trig ?= 'I_Mode_Trigger_Id' 	
;
 
t_subcomponent_subtypes:
	t_sub ?= 'I_Component' 
| 	t_cimpl_st ?= t_component_subtypes	
;

t_component_subtypes:
	t_annex_sub ?= 'I_Component_Annex' |
	t_abstract ?=	'I_Abstract' | t_sys ?= 'I_System' | t_dev ?= 'I_Device' |
	t_proc ?= 'I_Processor' | t_virt_proc ?= 'I_Virtual_Processor' |
		t_bus ?= 'I_Bus' | t_vbus ?= 'I_Virtual_Bus' | t_mem ?= 'I_Memory' | t_proc ?= 'I_Process' | 
		t_tg ?= 'I_Thread_Group' | t_t ?= 'I_Thread' | t_d ?= 'I_Data' | 
		t_subprog ?= 'I_Subprogram' | t_subprog_g ?= 'I_Subprogram_Group' 	
;

 
t_connection_subtypes:
	t_conn ?= 'I_Connection' | 
		t_feat_conn ?= 'I_Feature_Connection' | t_port_conn ?= 'I_Port_Connection' |
		t_parm_conn ?= 'I_Parameter_Connection' | t_acc_con ?= 'I_Access_Connection' | 
		t_fg_conn ?= 'I_Feature_Group_Connection'
;

t_feature_subtypes:
		t_feat ?= 'I_Feature' | 
		t_abs_feat ?= 'I_Abstract_Feature' | t_parm ?= 'I_Parameter' | t_fg ?= 'I_Feature_Group' | 
		t_port_subtypes | 
		t_access_subtypes

;

t_access_subtypes:
	t_access ?= 'I_Access' | t_data_acc ?= 'I_Data_Access' | t_sub_acc ?= 'I_Subprogram_Access' |
		t_sub_gr_acc ?= 'I_Subprogram_Group_Access' | t_bus_acc ?= 'I_Bus_Access'
;


t_port_subtypes:
	t_port ?= 'I_Port' | 
			t_d_port ?='I_Data_Port' | t_ev_port ?= 'I_Event_Port' | t_evd_port ?= 'I_Event_Data_Port'
	
;

t_flow_spec_subtypes:
		t_f_spec ?= 'I_Flow_Spec' | t_f_spec_source ?= 'I_Flow_Spec_Source' | 
		t_f_spec_sink ?= 'I_Flow_Spec_Sink' | t_f_spec_path ?= 'I_Flow_Spec_Path'
;

t_flow_impl_subtypes:
		t_f_i ?= 'I_Flow_Impl' | t_f_i_source ?= 'I_Flow_Impl_Source' | 
		t_f_i_sink ?= 'I_Flow_Impl_Sink' | t_f_i_path ?= 'I_Flow_Impl_Path' 
;

// from AADL.xtext


IntegerRange : //;returns aadl2::NumericRange:
	lowerBound=(IntegerTerm | SignedConstant | ConstantValue )
	'..' upperBound=(IntegerTerm | SignedConstant | ConstantValue )
	;

RealRange : //;returns aadl2::NumericRange:
	lowerBound=(RealTerm | SignedConstant | ConstantValue )
	'..' upperBound=(RealTerm | SignedConstant | ConstantValue )
	;

UnnamedIntegerType: //; returns aadl2::AadlInteger:
//	{aadl2::AadlInteger} 
{UnnamedIntegerType}
	('aadlinteger'|'int') (range=IntegerRange)? ( (ownedUnitsType=UnnamedUnitsType| ('units' referencedUnitsType=[aadl2::UnitsType|QPREF])))?
	 ;
UnnamedRealType: // returns aadl2::AadlReal:
//	{aadl2::AadlReal}
{UnnamedRealType}
	('aadlreal'|'real')(range=RealRange)? ((ownedUnitsType=UnnamedUnitsType| ('units' referencedUnitsType=[aadl2::UnitsType|QPREF])))?
	 ;
	 UnnamedUnitsType returns aadl2::UnitsType:
	'units'
	'(' ownedLiteral+=UnitLiteral (',' ownedLiteral+=UnitLiteralConversion)* ')';

UnitLiteral returns aadl2::UnitLiteral:
	name=ID;

UnitLiteralConversion returns aadl2::UnitLiteral:
	name=ID '=>' baseUnit=[aadl2::UnitLiteral|ID] STAR factor=NumberValue
	;
	 
UnnamedBooleanType returns aadl2::AadlBoolean:
	{aadl2::AadlBoolean} ('aadlboolean' | 'bool');
	 
NumberValue returns aadl2::NumberValue:
	RealLit | IntegerLit ;

RealLit returns aadl2::RealLiteral:
	value=SignedReal ;

IntegerLit returns aadl2::IntegerLiteral:
	value=SignedInt ;
	
	UnnamedStringType returns aadl2::AadlString:
	{aadl2::AadlString}('aadlstring'|'string');
	
UnnamedEnumerationType returns aadl2::EnumerationType:
	('enumeration'|'enum')
	'(' ownedLiteral+=EnumerationLiteral (',' ownedLiteral+=EnumerationLiteral)* ')';

UnnamedRangeType: // returns aadl2::RangeType:
//	{aadl2::RangeType}
	'range' 'of' (ownedNumberType=(UnnamedIntegerType|UnnamedRealType)
		| referencedNumberType=[aadl2::NumberType|QPREF]
	)
	 ;
// fully qualified classifier name (always includes package name
FQCREF:
	(ID '::')+ ID ->('.' ID)?;
