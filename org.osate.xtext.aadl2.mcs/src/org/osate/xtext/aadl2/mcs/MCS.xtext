grammar org.osate.xtext.aadl2.mcs.MCS with org.osate.xtext.aadl2.Aadl2 

generate mcs "http://www.osate.org/xtext/aadl2/mcs/MCS"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.osate.aadl2/model/aadl2.ecore" as aadl2



MCSGrammarRoot :    
       lib = MCSAnnexLibrary 
      | 'sub' subclause = MCSAnnexSubclause
;

AnnexLibrary returns aadl2::AnnexLibrary:
     MCSAnnexLibrary
;

AnnexSubclause returns aadl2::AnnexSubclause:
     MCSAnnexSubclause
;

MCSAnnexLibrary returns MCSAnnexLibrary:
	 {MCSAnnexLibrary}
	 ( 'theorems' (theorems += theorem_declaration)+)
    ( viewpoints += MCSViewpoint (viewpoints += MCSViewpoint)* )?
    ( enforceclauses += PackageEnforce (enforceclauses += PackageEnforce)* )?
;
	
MCSViewpoint returns MCSViewpoint:
    'viewpoint' name = ID policy = Enforcement_policy (pscript = PackageScript)? ';'
;

Enforcement_policy :
	(pack ?= 'package' | class ?= 'classifier') 'contract'
;

PackageScript :
	'script' (applies += AppliesToClause (c_block += ConstraintsBlock)+)*
	'endscript' ref = ViewpointReference ';'
;

AppliesToClause :
	'applies' 'to' (all ?= 'all' | 
					category = ClassifierCategory  //|
//					ref_to_c = ComponentClassifierReference //|
//					ref_to_f = FeatureGroupClassifierReference				
	)
;

ClassifierCategory :
	{ClassifierCategory}
	(component = ComponentCategory (ct = [aadl2::ComponentType|QCREF])? 
		         (impl ?= 'implementation' (ci = [aadl2::ComponentImplementation|QCREF])? )?
				| feat_g ?= 'feature group' (ref_to_f = FeatureGroupClassifierReference)? ) 
;

//ComponentClassifierReference : 
//	(ct = [aadl2::ComponentType|QCREF]   | 
 //    ci = [aadl2::ComponentImplementation|QCREF] 
//	)
//;

FeatureGroupClassifierReference: fg = [aadl2::FeatureGroupType|QCREF]
;

ViewpointReference :
	(policy = [Enforcement_policy])? vp_ref = [MCSViewpoint] ';'
;

ConstraintsBlock :
	 (b_label = block_label_id ':')? '{' (cs +=  labelled_check_statement)+ '}'
				 	 	
;

labelled_check_statement:
	(c_label = check_label_id)? cs = check_statement	
;
	

check_statement :
	check_theorem | check_assertion
;

block_label_id : name = ID;

check_label_id : name = ID;

check_theorem :
	'check' 'theorem' theo = [theorem_declaration] ('('root = root_element')')? (inmode = ModeSpec )?
			('fail' str = string_expression)? ';'
;

ModeSpec :
	'in' 'mode' mode = ModeName
;

ModeName : 
	name = ID					//temporary
;

check_assertion :
	'check' (root = root_element)? (inmode = ModeSpec)? expr = assertion_expression 
			('fail' str = string_expression)? ';'
;

root_element : 
	element_reference
;

element_reference : name = ID;    //temporary


PackageEnforce returns PackageEnforce:
    'enforce' viewpoint = [MCSViewpoint] ';'			//temporary
 ;

expression : expr = PropertyExpression;
	
assertion_expression : expr = expression;
string_expression : expr = expression;

MCSAnnexSubclause returns MCSAnnexSubclause:       //temporary
	 {MCSAnnexSubclause}
	( 'theorems' (theorems += theorem_declaration)+)
    ( enforceclauses += ClassifierEnforce (enforceclauses += ClassifierEnforce)* )?	
;

ClassifierEnforce :
	'enforce' viewpoint = [MCSViewpoint] script = ClassifierScript ';'
;

ClassifierScript : 
	'script' (c_block += ConstraintsBlock)*
	'endscript' ref = ViewpointReference ';'
;

theorem_declaration :
	'theorem' name=ID (ml ?= in_modes_list)? (locals += local_declaration)* (statements += theorem_statements)*
	'end' endname = ID ';'	
;

in_modes_list:
	'in' 'modes' (modes += ID )+
;

local_declaration:					//temporary
	constant_declaration
;

constant_declaration:
	'const' constant_identifier  (type = type_expression)? ':=' (left_expr = constant_expression) ';'
;

constant_identifier: name=ID
;

type_expression: 				//temporary
	basic_type
;

basic_type: bool = BooleanType | string = StringType
;

constant_expression: expression;

theorem_statements: statements = 'statements';