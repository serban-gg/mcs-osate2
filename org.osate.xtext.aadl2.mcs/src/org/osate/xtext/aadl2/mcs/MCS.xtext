grammar org.osate.xtext.aadl2.mcs.MCS with org.osate.xtext.aadl2.Aadl2

generate mcs "http://www.osate.org/xtext/aadl2/mcs/MCS"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.osate.aadl2/model/aadl2.ecore" as aadl2
//import "http://www.eclipse.org/xtext/xbase/Xbase"

MCSGrammarRoot :    
        'annex' lib = MCSAnnexLibrary 
        | 'file' file = MCSFileLibrary
        | 'subclause' subclause = MCSAnnexSubclause
;
/* 
AnnexLibrary returns aadl2::AnnexLibrary:
     MCSAnnexLibrary
;

AnnexSubclause returns aadl2::AnnexSubclause:
     MCSAnnexSubclause
;
*/

MCSAnnexLibrary returns MCSAnnexLibrary:
	 {MCSAnnexLibrary}
	  ('consts' (constants += Constant_declaration)+)?
	  ('functions' (functions += F_or_T_declaration)+)?
	 ( 'theorems' (theorems += F_or_T_declaration)+)?
;
 
MCSFileLibrary:
	{MCSFileLibrary}
	  ('with' (importedUnit+=[aadl2::ModelUnit])  
	                     (',' importedUnit+=[aadl2::ModelUnit])*)
	  ('import' (files += File_name)+ (',' packs += File_name)*)?
	  ('constants' (constants += Constant_declaration)+)?
	  ('functions' (functions += F_or_T_declaration)+)?
	  ('theorems' (theorems += F_or_T_declaration)+)?
	  ('constraints' (calls += Theorem_call)+)?
;

MCSAnnexSubclause returns MCSAnnexSubclause:       
	 {MCSAnnexSubclause}
	(  (calls += Theorem_call)+)?
;

File_name:
	STRING
;

Constant_declaration returns Constant :
	name=ID ':' (type = Type_expression)? '='  left_expr = Expr ';' 
  | 'type' name=ID  '=' type = Type_expression ';'
;

F_or_T_declaration returns F_or_T:
	name=ID (t_root ?= Theorem_root)? '(' (args+=Parameter (',' args+=Parameter)*)? ')' body=DefinitionBody
;
	
Theorem_root:
	'<' 'root' ':' ( nilroot ?= 'nil' | classifier = T_classifier_subtypes) '>'
;

DefinitionBody:
	{FunctionBody} ':' type=Type_expression '=' expr=Expr
  | {ClaimBody} '<=' ('**'(claim+=Parm_string)+'**') expr=Expr
;

//Arg types are used for functions, claims, and quantifiers

Parameter returns Arg: 
	(name=ID ':' type=Type_expression)
;

Parm_string:
	 {ClaimString} str=STRING 
| 	 {ClaimArg} arg=[ClaimTextVar] ('%' unit=[aadl2::UnitLiteral])?
;

ClaimTextVar: parm?= Parameter | const?=Constant_declaration | letb?=Let_binding;

Theorem_call returns TheoremCall:
    'check' name = [F_or_T]                   // must be a theorem reference 
           ('<' ('nil'| croot = Classifier_literal) '>')?
             '(' (actarg += Expr ( ',' actarg += Expr)*)? ')'
;

Classifier_literal:
	classlit = [aadl2::ComponentClassifier| FQCREF] 
	| Mcs_name
;

RealTerm returns aadl2::RealLiteral:
	value=UnsignedReal (unit=[aadl2::UnitLiteral|ID])?
;

UnsignedReal returns aadl2::Real:
	REAL_LIT
;

IntegerTerm returns aadl2::IntegerLiteral:
	value=UnsignedInt (unit=[aadl2::UnitLiteral|ID])?
;

UnsignedInt returns aadl2::Integer:
	INTEGER_LIT
;

Range returns aadl2::NumericRange:
	lowerBound=(IntegerTerm | RealTerm  /*| ConstantValue */ )
	 '..' upperBound=(IntegerTerm |RealTerm /*| ConstantValue */ )
	;

ReferenceTerm:
  'reference' '(' 	(root ?= 'root' '.')?
  path=ContainmentPathElement
  ')'
  ;

Mcs_name:
	name=ID      // global constant, parameter or let binding local
;

Mcs_name_ref:
	Mcs_name  ('.' ( -> builtin+=[BuiltInFnCallExpr] | method+=[FnCallExpr]))* 
;

Let_binding:
	name=ID ':' type = Type_expression '=' expr=Expr ';'
;

Expr:
	ImpliesExpr // ( '<' newtype = Type_expression '>')?
;

ImpliesExpr returns Expr:
	OrExpr (=>({BinaryExpr.left=current} op='=>') right=ImpliesExpr)?
;

OrExpr returns Expr:
	AndExpr (=>({BinaryExpr.left=current} op='or') right=AndExpr)*
;

AndExpr returns Expr:
	InstanceOfExpr (=>({BinaryExpr.left=current} (op='and'|op='andthen')) right=InstanceOfExpr)*
;

InstanceOfExpr returns Expr:
	RelationalExpr (=>({InstanceOfExpr.expr=current} 'instanceof') type=Type_expression)?
;

RelationalOp:
	'<' | '<=' | '>' | '>=' | '=' | '<>'
;
 
RelationalExpr returns Expr:
	PlusExpr (=>({BinaryExpr.left=current} op=RelationalOp) right=PlusExpr)?
;

PlusExpr returns Expr:
	TimesExpr (=>({BinaryExpr.left=current} op=('+' | '-')) right=TimesExpr)*
;

TimesExpr returns Expr:
	PrefixExpr (=>({BinaryExpr.left=current} op=('*' | '/' | '%')) right=PrefixExpr)*	
;

PrefixExpr returns Expr:
	{UnaryExpr} op = ('-' | 'not') expr=PrefixExpr
//|   {PreCastExpr} '(' type=Type_expression ')' expr=PrefixExpr
|	{PostCastExpr} expr = Expression_term => ( '<' newtype = Type_expression '>')?
;


Domain:
	name=ID 'in' expr=Expr					// must be a set expression
;

Expression_term returns Expr:
	
	{MCSNameExpr} (root ?= 'root' | iroot ?='iroot' |   nil ?= 'nil' 
| 	empty ?= 'empty'	| allmodes ?= 'allmodes' | nameref = Mcs_name_ref)
|	{PkgExpr} 'package' '(' package = [aadl2::AadlPackage] ')'
|   {CompExpr} classifier = ComponentClassifierTerm   // rules identical to
|   {RefExpr} reference = ReferenceTerm			      // Properties.xtext expressions
//|   {IdExpr} => id = [aadl2::NamedElement | QCREF]
|	{ThisExpr} 'this' ('.' sub = ContainmentPath)? // from Properties grammar
|	{IntExpr} val=IntegerTerm
|   {RealExpr} val=RealTerm
|	{BoolExpr} val=BooleanLiteral
|   {StringExpr} val=StringTerm
|	{Range} val=Range       		// Int and Real Range from AADL.xtext
|	{IfThenElseExpr} 'if' cond=Expr 'then' then=Expr 'else' else=Expr
|   {QuantifiedExpr} quant=( 'forall' | 'foreach' | 'exists') 
								('(' args+=Parameter ')')+ '.' expr=Expr
|   {BuiltInFnCallExpr} fn=BuiltInFn '(' (args+=(Expr) (',' args+=(Expr))*)? ')'
|   {BuiltPropertyExists} 'has_property' '(' property=[aadl2::Property|QPREF]
										(',' modeset = Expr (',' inbind = Expr)?)?
									  ')'
|   {BuiltPropertyVal} 'property' '(' property=[aadl2::Property|QPREF]
									(',' modeset = Expr (',' inbind = Expr)?)?
							   ')'	
|	{FnCallExpr} fn=[F_or_T] '(' (args+=(Expr) (',' args+=(Expr))*)? ')'
|   {TheoremCall} fn=Theorem_call
								  
|   (list?='list')? '{' exp=Expr ( ({FilterMapExpr.map=current} 
						           'for' ('(' args+=(Parameter|Domain) ')')+ 
						          	 ('|' filter=Expr)?)
             		      	   | ({SetExpr.exprs+=current} (',' exprs+=Expr)*)) '}'
|   {Empty} '{' '}'
|   {LetExpr} binding=Let_binding ';' expr=Expr
|	'(' Expr ')' ('.' ( -> builtin+=[BuiltInFnCallExpr] | method+=[FnCallExpr]))* 
;

BuiltInFn:
// real primary type methods
	'has_range'| 'range'| 'floor' | 'ceiling'
// integer and real primary type 
|	'has_units' | 'unit_literal'
// range of integer, real primary type 
|	'upper' | 'lower' | 'has_delta' | 'delta'
// string primary type 
|	'concat' | 'eq' | 'case_eq' | 'in'
// set methods
| 	'union' | 'intersect' 
// set and list methods 
|	'has_member' |	'size' | 'sum' | 'max' | 'min'
// list methods
|	'get' | 'sublist' | 'join' | 'as_set'
// mapping methods
|	'key' | 'val'
// T_Element methods
|	'qualified_name' | 'local_name' | 'path_name_of' | 'package_name'
|	'is_owned_by' | 'has_parent' | 'parent' | 'owner' | 'equal' | 'element_type'
//|	'has_property' | 'property' implemented explicitly as exptession terms
// T_Package methods
|	'imports' | 'classifiers'
// T_Classifier methods
|	'has_extends' | 'extends' | 'category'
// T_Classifier and I_Component methods
| 'has_bindings' | 'bindings_map' 
//	C_Impl methods
|	'component_type' | 'is_of_type'
//	C_Feature_Group methods
|	'has_inverse' | 'inverse'
//	T_Instance methods
|	'contaned' | 'in_modes'
//	I_Component methods
|	'is_prototype_ref' | 'prototype' | 'is_c_type_instance' | 'c_type'
|	'class'  // duplicate names | 'has_bindings' | 'bindings_map'
|	'array_cardinal' | 'modes' | 'modes_map' | 'mode_state_machine' 
|	'mode_transitions' | 'subcomponents' | 'instances'
// 	I_Component, I_Feature and I_Call_Sequence methods
|	'features' | 'flat_features' 
// 	I_Component and I_Call_Sequence methods
| 'connections'
//	I_Subprogram_Call methods
|	'call_target'
//	I_Connection methods
|	'is_bidirectional' | 'source' | 'destination'
//	I_Feature, I_Flow_Spec I_End_To_End methods
|	'is_refined' 
//	I_Feature methods
| 'is_partial' | 'has_prototype_ref' // % duplicate | 'prototype' | 'array_cardinal'
|	'has_classifier_type' | 'classifier_type' | 'direction' 
//	I_Feature group methods
| 'is_inverse'  // duplicate | 'has_bindings' | 'bindings_map' |	'features' | 'flat_features' 
//	I_Flow_Spec, I_Flow_Impl methods
|	'feature'  //duplicate | 'is_refined'
//	I_Flow_Impl,I_End_To_End_Flow methods
|	'path'  //duplicate for I_Flow_Impl | 'feature' 
//	I_End_To_End_Flow methods
|   'transitive_path' //duplicate |	'is_refined' | 'path' 
//	I_Prototype methods
|	'is_component_prototype' | 'type_literal' | 'has_list' | 'is_feature_prototype'
|	'is_fg_prototype' | 'has_classifier_reference' | 'classifier_reference'
//	I_Mode methods
|	'is_initial_mode' | 'is_required_mode' | 'mapped_set'
//	I_Mode_Transition methods
| 	'is_named' | 'transition_name' | 'transition_triggers'
|	'start_mode_state' | 'end_mode_state'
;

// Type rules

Type_expression: 				
	 basic = Basic_type |
	 composite = Composite_type |
	 element = Element_type
;
 
 // basic types rules
 
Basic_type:
	ptype = 'property_type' | 
	pref = 'property_ref' | 
	bool = UnnamedBooleanType | 				// from core AADL
	string = UnnamedStringType |
	enumer = UnnamedEnumerationType |
	units = UnnamedUnitsType |
 	integer = UnnamedIntegerType |
	real = UnnamedRealType |
	range= UnnamedRangeType |  
	class=UnnamedClassifierType |
	ref=UnnamedReferenceType |
	typename = [Constant]         // must be a user defined type
;

// composite type rules

Composite_type :
		Mapping_type |
		Set_type |
		List_type |
		Record_type |
		Union_type
;

Mapping_type:
	'(' key=[Type_expression] 'to' val=[Type_expression] ')'
;

Set_type:
	'{' root_type=[Type_expression] '}'
|	'set' '<' root_type=[Type_expression] '>'
;

List_type:
	'(' root_type=[Type_expression] ')'
|	'list' '<' root_type=[Type_expression] '>'
;

Record_type:
	'record'  '( '( field += Id_type_pair)+ ')'
;

Union_type:
	'union' '('  types += [Type_expression] (','type += [Type_expression] )* ')'
;

Id_type_pair : 
	 name=ID ':' type= Type_expression
;

//element type rules

Element_type : 
	telem ?= 'T_Element' 
|	tpack ?= 'T_Package'		
|	t_class ?= Classifiers 
|	t_inst ?= Instances
;

Classifiers:
	t_class ?='T_Classifier' 				
|	t_class_subtype ?= T_classifier_subtypes	
;

T_classifier_subtypes:
	t_ctype ?='C_Type'  
|	t_cimpl ?='C_Impl' 
|	t_fgclass ?= 'C_Feature_Group'  
|	t_annexclass ?= 'C_Annex'	
;

Instances:
	inst ?= 'T_Instance' |  t_inst_st ?= t_instance_subtypes	
;
 
t_instance_subtypes:
	t_subc_st ?= t_subcomponent_subtypes   
|	t_connection_subtypes  
|	t_feature_subtypes  
|	t_flow_spec_subtypes | t_flow_impl_subtypes  
|	t_sbcall ?= 'I_Subprogram_Call'  
|	t_callseq ?= 'I_Call_Sequence' 
|	t_eeflow ?= 'I_End_To_End_Flow' 
|	t_proto ?= 'I_Prototype' 
|	t_mode ?= 'I_Mode'  
|	t_mod_trans ?= 'I_Mode_Transition' 
| 	t_mode_trig ?= 'I_Mode_Trigger_Id' 	
;
 
t_subcomponent_subtypes:
	t_sub ?= 'I_Component' 
| 	t_cimpl_st ?= t_component_subtypes	
;

t_component_subtypes:
	t_annex_sub ?= 'I_Component_Annex' |
	t_abstract ?=	'I_Abstract' | t_sys ?= 'I_System' | t_dev ?= 'I_Device' |
	t_proc ?= 'I_Processor' | t_virt_proc ?= 'I_Virtual_Processor' |
		t_bus ?= 'I_Bus' | t_vbus ?= 'I_Virtual_Bus' | t_mem ?= 'I_Memory' | t_proc ?= 'I_Process' | 
		t_tg ?= 'I_Thread_Group' | t_t ?= 'I_Thread' | t_d ?= 'I_Data' | 
		t_subprog ?= 'I_Subprogram' | t_subprog_g ?= 'I_Subprogram_Group' 	
;

 
t_connection_subtypes:
	t_conn ?= 'I_Connection' | 
		t_feat_conn ?= 'I_Feature_Connection' | t_port_conn ?= 'I_Port_Connection' |
		t_parm_conn ?= 'I_Parameter_Connection' | t_acc_con ?= 'I_Access_Connection' | 
		t_fg_conn ?= 'I_Feature_Group_Connection'
;

t_feature_subtypes:
		t_feat ?= 'I_Feature' | 
		t_abs_feat ?= 'I_Abstract_Feature' | t_parm ?= 'I_Parameter' | t_fg ?= 'I_Feature_Group' | 
		t_port_subtypes | 
		t_access_subtypes

;

t_access_subtypes:
	t_access ?= 'I_Access' | t_data_acc ?= 'I_Data_Access' | t_sub_acc ?= 'I_Subprogram_Access' |
		t_sub_gr_acc ?= 'I_Subprogram_Group_Access' | t_bus_acc ?= 'I_Bus_Access'
;


t_port_subtypes:
	t_port ?= 'I_Port' | 
			t_d_port ?='I_Data_Port' | t_ev_port ?= 'I_Event_Port' | t_evd_port ?= 'I_Event_Data_Port'
	
;

t_flow_spec_subtypes:
		t_f_spec ?= 'I_Flow_Spec' | t_f_spec_source ?= 'I_Flow_Spec_Source' | 
		t_f_spec_sink ?= 'I_Flow_Spec_Sink' | t_f_spec_path ?= 'I_Flow_Spec_Path'
;

t_flow_impl_subtypes:
		t_f_i ?= 'I_Flow_Impl' | t_f_i_source ?= 'I_Flow_Impl_Source' | 
		t_f_i_sink ?= 'I_Flow_Impl_Sink' | t_f_i_path ?= 'I_Flow_Impl_Path' 
;
