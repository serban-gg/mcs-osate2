/*
 * generated by Xtext
 */
package org.osate.xtext.aadl2.mcs.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.osate.aadl2.Aadl2Package;
import org.osate.aadl2.AadlBoolean;
import org.osate.aadl2.AadlInteger;
import org.osate.aadl2.AadlPackage;
import org.osate.aadl2.AadlReal;
import org.osate.aadl2.AadlString;
import org.osate.aadl2.AbstractFeature;
import org.osate.aadl2.AbstractImplementation;
import org.osate.aadl2.AbstractPrototype;
import org.osate.aadl2.AbstractSubcomponent;
import org.osate.aadl2.AbstractType;
import org.osate.aadl2.AccessConnection;
import org.osate.aadl2.AccessSpecification;
import org.osate.aadl2.ArrayDimension;
import org.osate.aadl2.ArrayRange;
import org.osate.aadl2.ArraySize;
import org.osate.aadl2.BasicProperty;
import org.osate.aadl2.BasicPropertyAssociation;
import org.osate.aadl2.BooleanLiteral;
import org.osate.aadl2.BusAccess;
import org.osate.aadl2.BusImplementation;
import org.osate.aadl2.BusPrototype;
import org.osate.aadl2.BusSubcomponent;
import org.osate.aadl2.BusType;
import org.osate.aadl2.ClassifierType;
import org.osate.aadl2.ClassifierValue;
import org.osate.aadl2.ComponentImplementationReference;
import org.osate.aadl2.ComponentPrototypeActual;
import org.osate.aadl2.ComponentPrototypeBinding;
import org.osate.aadl2.ComponentTypeRename;
import org.osate.aadl2.ComputedValue;
import org.osate.aadl2.ConnectedElement;
import org.osate.aadl2.ContainedNamedElement;
import org.osate.aadl2.ContainmentPathElement;
import org.osate.aadl2.DataAccess;
import org.osate.aadl2.DataImplementation;
import org.osate.aadl2.DataPort;
import org.osate.aadl2.DataPrototype;
import org.osate.aadl2.DataSubcomponent;
import org.osate.aadl2.DataType;
import org.osate.aadl2.DefaultAnnexLibrary;
import org.osate.aadl2.DefaultAnnexSubclause;
import org.osate.aadl2.DeviceImplementation;
import org.osate.aadl2.DevicePrototype;
import org.osate.aadl2.DeviceSubcomponent;
import org.osate.aadl2.DeviceType;
import org.osate.aadl2.EndToEndFlow;
import org.osate.aadl2.EndToEndFlowSegment;
import org.osate.aadl2.EnumerationLiteral;
import org.osate.aadl2.EnumerationType;
import org.osate.aadl2.EventDataPort;
import org.osate.aadl2.EventDataSource;
import org.osate.aadl2.EventPort;
import org.osate.aadl2.EventSource;
import org.osate.aadl2.FeatureConnection;
import org.osate.aadl2.FeatureGroup;
import org.osate.aadl2.FeatureGroupConnection;
import org.osate.aadl2.FeatureGroupPrototype;
import org.osate.aadl2.FeatureGroupPrototypeActual;
import org.osate.aadl2.FeatureGroupPrototypeBinding;
import org.osate.aadl2.FeatureGroupType;
import org.osate.aadl2.FeatureGroupTypeRename;
import org.osate.aadl2.FeaturePrototype;
import org.osate.aadl2.FeaturePrototypeBinding;
import org.osate.aadl2.FeaturePrototypeReference;
import org.osate.aadl2.FlowEnd;
import org.osate.aadl2.FlowImplementation;
import org.osate.aadl2.FlowSegment;
import org.osate.aadl2.FlowSpecification;
import org.osate.aadl2.GroupExtension;
import org.osate.aadl2.ImplementationExtension;
import org.osate.aadl2.IntegerLiteral;
import org.osate.aadl2.ListType;
import org.osate.aadl2.ListValue;
import org.osate.aadl2.MemoryImplementation;
import org.osate.aadl2.MemoryPrototype;
import org.osate.aadl2.MemorySubcomponent;
import org.osate.aadl2.MemoryType;
import org.osate.aadl2.MetaclassReference;
import org.osate.aadl2.ModalPropertyValue;
import org.osate.aadl2.Mode;
import org.osate.aadl2.ModeBinding;
import org.osate.aadl2.ModeTransition;
import org.osate.aadl2.ModeTransitionTrigger;
import org.osate.aadl2.NamedValue;
import org.osate.aadl2.NumericRange;
import org.osate.aadl2.Operation;
import org.osate.aadl2.PackageRename;
import org.osate.aadl2.Parameter;
import org.osate.aadl2.ParameterConnection;
import org.osate.aadl2.PortConnection;
import org.osate.aadl2.PortProxy;
import org.osate.aadl2.PortSpecification;
import org.osate.aadl2.PrivatePackageSection;
import org.osate.aadl2.ProcessImplementation;
import org.osate.aadl2.ProcessPrototype;
import org.osate.aadl2.ProcessSubcomponent;
import org.osate.aadl2.ProcessType;
import org.osate.aadl2.ProcessorImplementation;
import org.osate.aadl2.ProcessorPrototype;
import org.osate.aadl2.ProcessorSubcomponent;
import org.osate.aadl2.ProcessorType;
import org.osate.aadl2.Property;
import org.osate.aadl2.PropertyAssociation;
import org.osate.aadl2.PropertyConstant;
import org.osate.aadl2.PropertySet;
import org.osate.aadl2.PublicPackageSection;
import org.osate.aadl2.RangeType;
import org.osate.aadl2.RangeValue;
import org.osate.aadl2.RealLiteral;
import org.osate.aadl2.Realization;
import org.osate.aadl2.RecordType;
import org.osate.aadl2.RecordValue;
import org.osate.aadl2.ReferenceType;
import org.osate.aadl2.ReferenceValue;
import org.osate.aadl2.StringLiteral;
import org.osate.aadl2.SubprogramAccess;
import org.osate.aadl2.SubprogramCall;
import org.osate.aadl2.SubprogramCallSequence;
import org.osate.aadl2.SubprogramGroupAccess;
import org.osate.aadl2.SubprogramGroupImplementation;
import org.osate.aadl2.SubprogramGroupPrototype;
import org.osate.aadl2.SubprogramGroupSubcomponent;
import org.osate.aadl2.SubprogramGroupType;
import org.osate.aadl2.SubprogramImplementation;
import org.osate.aadl2.SubprogramPrototype;
import org.osate.aadl2.SubprogramProxy;
import org.osate.aadl2.SubprogramSubcomponent;
import org.osate.aadl2.SubprogramType;
import org.osate.aadl2.SystemImplementation;
import org.osate.aadl2.SystemPrototype;
import org.osate.aadl2.SystemSubcomponent;
import org.osate.aadl2.SystemType;
import org.osate.aadl2.ThreadGroupImplementation;
import org.osate.aadl2.ThreadGroupPrototype;
import org.osate.aadl2.ThreadGroupSubcomponent;
import org.osate.aadl2.ThreadGroupType;
import org.osate.aadl2.ThreadImplementation;
import org.osate.aadl2.ThreadPrototype;
import org.osate.aadl2.ThreadSubcomponent;
import org.osate.aadl2.ThreadType;
import org.osate.aadl2.TypeExtension;
import org.osate.aadl2.UnitLiteral;
import org.osate.aadl2.UnitsType;
import org.osate.aadl2.VirtualBusImplementation;
import org.osate.aadl2.VirtualBusPrototype;
import org.osate.aadl2.VirtualBusSubcomponent;
import org.osate.aadl2.VirtualBusType;
import org.osate.aadl2.VirtualProcessorImplementation;
import org.osate.aadl2.VirtualProcessorPrototype;
import org.osate.aadl2.VirtualProcessorSubcomponent;
import org.osate.aadl2.VirtualProcessorType;
import org.osate.xtext.aadl2.mcs.mcs.AppliesToClause;
import org.osate.xtext.aadl2.mcs.mcs.ClassifierCategory;
import org.osate.xtext.aadl2.mcs.mcs.ClassifierEnforce;
import org.osate.xtext.aadl2.mcs.mcs.ClassifierScript;
import org.osate.xtext.aadl2.mcs.mcs.ConstraintsBlock;
import org.osate.xtext.aadl2.mcs.mcs.Enforcement_policy;
import org.osate.xtext.aadl2.mcs.mcs.FeatureGroupClassifierReference;
import org.osate.xtext.aadl2.mcs.mcs.MCSAnnexLibrary;
import org.osate.xtext.aadl2.mcs.mcs.MCSAnnexSubclause;
import org.osate.xtext.aadl2.mcs.mcs.MCSGrammarRoot;
import org.osate.xtext.aadl2.mcs.mcs.MCSViewpoint;
import org.osate.xtext.aadl2.mcs.mcs.McsPackage;
import org.osate.xtext.aadl2.mcs.mcs.ModeName;
import org.osate.xtext.aadl2.mcs.mcs.ModeSpec;
import org.osate.xtext.aadl2.mcs.mcs.PackageEnforce;
import org.osate.xtext.aadl2.mcs.mcs.PackageScript;
import org.osate.xtext.aadl2.mcs.mcs.ViewpointReference;
import org.osate.xtext.aadl2.mcs.mcs.assertion_expression;
import org.osate.xtext.aadl2.mcs.mcs.basic_type;
import org.osate.xtext.aadl2.mcs.mcs.block_label_id;
import org.osate.xtext.aadl2.mcs.mcs.check_assertion;
import org.osate.xtext.aadl2.mcs.mcs.check_label_id;
import org.osate.xtext.aadl2.mcs.mcs.check_theorem;
import org.osate.xtext.aadl2.mcs.mcs.constant_identifier;
import org.osate.xtext.aadl2.mcs.mcs.element_reference;
import org.osate.xtext.aadl2.mcs.mcs.expression;
import org.osate.xtext.aadl2.mcs.mcs.in_modes_list;
import org.osate.xtext.aadl2.mcs.mcs.labelled_check_statement;
import org.osate.xtext.aadl2.mcs.mcs.string_expression;
import org.osate.xtext.aadl2.mcs.mcs.theorem_declaration;
import org.osate.xtext.aadl2.mcs.mcs.theorem_statements;
import org.osate.xtext.aadl2.mcs.services.MCSGrammarAccess;
import org.osate.xtext.aadl2.serializer.Aadl2SemanticSequencer;

@SuppressWarnings("all")
public class MCSSemanticSequencer extends Aadl2SemanticSequencer {

	@Inject
	private MCSGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == Aadl2Package.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case Aadl2Package.AADL_BOOLEAN:
				if(context == grammarAccess.getBooleanTypeRule() ||
				   context == grammarAccess.getPropertyTypeRule()) {
					sequence_BooleanType(context, (AadlBoolean) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUnnamedBooleanTypeRule() ||
				   context == grammarAccess.getUnnamedPropertyTypeRule()) {
					sequence_UnnamedBooleanType(context, (AadlBoolean) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.AADL_INTEGER:
				if(context == grammarAccess.getIntegerTypeRule() ||
				   context == grammarAccess.getPropertyTypeRule()) {
					sequence_IntegerType(context, (AadlInteger) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUnnamedIntegerTypeRule() ||
				   context == grammarAccess.getUnnamedPropertyTypeRule()) {
					sequence_UnnamedIntegerType(context, (AadlInteger) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.AADL_PACKAGE:
				sequence_AadlPackage(context, (AadlPackage) semanticObject); 
				return; 
			case Aadl2Package.AADL_REAL:
				if(context == grammarAccess.getPropertyTypeRule() ||
				   context == grammarAccess.getRealTypeRule()) {
					sequence_RealType(context, (AadlReal) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUnnamedPropertyTypeRule() ||
				   context == grammarAccess.getUnnamedRealTypeRule()) {
					sequence_UnnamedRealType(context, (AadlReal) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.AADL_STRING:
				if(context == grammarAccess.getPropertyTypeRule() ||
				   context == grammarAccess.getStringTypeRule()) {
					sequence_StringType(context, (AadlString) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUnnamedPropertyTypeRule() ||
				   context == grammarAccess.getUnnamedStringTypeRule()) {
					sequence_UnnamedStringType(context, (AadlString) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.ABSTRACT_FEATURE:
				sequence_AbstractFeature(context, (AbstractFeature) semanticObject); 
				return; 
			case Aadl2Package.ABSTRACT_IMPLEMENTATION:
				sequence_AbstractImplementation(context, (AbstractImplementation) semanticObject); 
				return; 
			case Aadl2Package.ABSTRACT_PROTOTYPE:
				if(context == grammarAccess.getAbstractPrototypeRule() ||
				   context == grammarAccess.getComponentPrototypeRule()) {
					sequence_AbstractPrototype(context, (AbstractPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPrototypeRule()) {
					sequence_AbstractPrototype_Prototype(context, (AbstractPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.ABSTRACT_SUBCOMPONENT:
				sequence_AbstractSubcomponent(context, (AbstractSubcomponent) semanticObject); 
				return; 
			case Aadl2Package.ABSTRACT_TYPE:
				sequence_AbstractType(context, (AbstractType) semanticObject); 
				return; 
			case Aadl2Package.ACCESS_CONNECTION:
				sequence_AccessConnection(context, (AccessConnection) semanticObject); 
				return; 
			case Aadl2Package.ACCESS_SPECIFICATION:
				sequence_AccessSpecification(context, (AccessSpecification) semanticObject); 
				return; 
			case Aadl2Package.ARRAY_DIMENSION:
				sequence_ArrayDimension(context, (ArrayDimension) semanticObject); 
				return; 
			case Aadl2Package.ARRAY_RANGE:
				sequence_ArrayRange(context, (ArrayRange) semanticObject); 
				return; 
			case Aadl2Package.ARRAY_SIZE:
				sequence_ArraySize(context, (ArraySize) semanticObject); 
				return; 
			case Aadl2Package.BASIC_PROPERTY:
				sequence_RecordField(context, (BasicProperty) semanticObject); 
				return; 
			case Aadl2Package.BASIC_PROPERTY_ASSOCIATION:
				sequence_FieldPropertyAssociation(context, (BasicPropertyAssociation) semanticObject); 
				return; 
			case Aadl2Package.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case Aadl2Package.BUS_ACCESS:
				sequence_BusAccess(context, (BusAccess) semanticObject); 
				return; 
			case Aadl2Package.BUS_IMPLEMENTATION:
				sequence_BusImplementation(context, (BusImplementation) semanticObject); 
				return; 
			case Aadl2Package.BUS_PROTOTYPE:
				if(context == grammarAccess.getBusPrototypeRule() ||
				   context == grammarAccess.getComponentPrototypeRule()) {
					sequence_BusPrototype(context, (BusPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPrototypeRule()) {
					sequence_BusPrototype_Prototype(context, (BusPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.BUS_SUBCOMPONENT:
				sequence_BusSubcomponent(context, (BusSubcomponent) semanticObject); 
				return; 
			case Aadl2Package.BUS_TYPE:
				sequence_BusType(context, (BusType) semanticObject); 
				return; 
			case Aadl2Package.CLASSIFIER_TYPE:
				if(context == grammarAccess.getClassifierTypeRule() ||
				   context == grammarAccess.getPropertyTypeRule()) {
					sequence_ClassifierType(context, (ClassifierType) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUnnamedClassifierTypeRule() ||
				   context == grammarAccess.getUnnamedPropertyTypeRule()) {
					sequence_UnnamedClassifierType(context, (ClassifierType) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.CLASSIFIER_VALUE:
				if(context == grammarAccess.getComponentClassifierTermRule() ||
				   context == grammarAccess.getConstantPropertyExpressionRule() ||
				   context == grammarAccess.getPropertyExpressionRule()) {
					sequence_ComponentClassifierTerm(context, (ClassifierValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPropertyOwnerRule() ||
				   context == grammarAccess.getQCReferenceRule()) {
					sequence_QCReference(context, (ClassifierValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.COMPONENT_IMPLEMENTATION_REFERENCE:
				sequence_ComponentImplementationReference(context, (ComponentImplementationReference) semanticObject); 
				return; 
			case Aadl2Package.COMPONENT_PROTOTYPE_ACTUAL:
				sequence_ComponentReference(context, (ComponentPrototypeActual) semanticObject); 
				return; 
			case Aadl2Package.COMPONENT_PROTOTYPE_BINDING:
				sequence_ComponentPrototypeBinding(context, (ComponentPrototypeBinding) semanticObject); 
				return; 
			case Aadl2Package.COMPONENT_TYPE_RENAME:
				sequence_CTRename(context, (ComponentTypeRename) semanticObject); 
				return; 
			case Aadl2Package.COMPUTED_VALUE:
				sequence_ComputedTerm(context, (ComputedValue) semanticObject); 
				return; 
			case Aadl2Package.CONNECTED_ELEMENT:
				if(context == grammarAccess.getAbstractConnectionEndRule()) {
					sequence_AbstractConnectionEnd_ConnectedElement_InternalEvent_ProcessorPort(context, (ConnectedElement) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAccessConnectionEndRule()) {
					sequence_AccessConnectionEnd_ConnectedElement_ProcessorSubprogram(context, (ConnectedElement) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getConnectedElementRule()) {
					sequence_ConnectedElement(context, (ConnectedElement) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getProcessorConnectionEndRule()) {
					sequence_ConnectedElement_ProcessorConnectionEnd_ProcessorPort(context, (ConnectedElement) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInternalEventRule()) {
					sequence_InternalEvent(context, (ConnectedElement) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getProcessorPortRule()) {
					sequence_ProcessorPort(context, (ConnectedElement) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getProcessorSubprogramRule()) {
					sequence_ProcessorSubprogram(context, (ConnectedElement) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.CONTAINED_NAMED_ELEMENT:
				sequence_ContainmentPath(context, (ContainedNamedElement) semanticObject); 
				return; 
			case Aadl2Package.CONTAINMENT_PATH_ELEMENT:
				sequence_ContainmentPathElement(context, (ContainmentPathElement) semanticObject); 
				return; 
			case Aadl2Package.DATA_ACCESS:
				sequence_DataAccess(context, (DataAccess) semanticObject); 
				return; 
			case Aadl2Package.DATA_IMPLEMENTATION:
				sequence_DataImplementation(context, (DataImplementation) semanticObject); 
				return; 
			case Aadl2Package.DATA_PORT:
				sequence_DataPort(context, (DataPort) semanticObject); 
				return; 
			case Aadl2Package.DATA_PROTOTYPE:
				if(context == grammarAccess.getComponentPrototypeRule() ||
				   context == grammarAccess.getDataPrototypeRule()) {
					sequence_DataPrototype(context, (DataPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPrototypeRule()) {
					sequence_DataPrototype_Prototype(context, (DataPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.DATA_SUBCOMPONENT:
				sequence_DataSubcomponent(context, (DataSubcomponent) semanticObject); 
				return; 
			case Aadl2Package.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case Aadl2Package.DEFAULT_ANNEX_LIBRARY:
				sequence_DefaultAnnexLibrary(context, (DefaultAnnexLibrary) semanticObject); 
				return; 
			case Aadl2Package.DEFAULT_ANNEX_SUBCLAUSE:
				sequence_DefaultAnnexSubclause(context, (DefaultAnnexSubclause) semanticObject); 
				return; 
			case Aadl2Package.DEVICE_IMPLEMENTATION:
				sequence_DeviceImplementation(context, (DeviceImplementation) semanticObject); 
				return; 
			case Aadl2Package.DEVICE_PROTOTYPE:
				if(context == grammarAccess.getComponentPrototypeRule() ||
				   context == grammarAccess.getDevicePrototypeRule()) {
					sequence_DevicePrototype(context, (DevicePrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPrototypeRule()) {
					sequence_DevicePrototype_Prototype(context, (DevicePrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.DEVICE_SUBCOMPONENT:
				sequence_DeviceSubcomponent(context, (DeviceSubcomponent) semanticObject); 
				return; 
			case Aadl2Package.DEVICE_TYPE:
				sequence_DeviceType(context, (DeviceType) semanticObject); 
				return; 
			case Aadl2Package.END_TO_END_FLOW:
				sequence_EndToEndFlow(context, (EndToEndFlow) semanticObject); 
				return; 
			case Aadl2Package.END_TO_END_FLOW_SEGMENT:
				if(context == grammarAccess.getETEConnectionFlowRule()) {
					sequence_ETEConnectionFlow(context, (EndToEndFlowSegment) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getETESubcomponentFlowRule()) {
					sequence_ETESubcomponentFlow(context, (EndToEndFlowSegment) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.ENUMERATION_LITERAL:
				sequence_EnumerationLiteral(context, (EnumerationLiteral) semanticObject); 
				return; 
			case Aadl2Package.ENUMERATION_TYPE:
				if(context == grammarAccess.getEnumerationTypeRule() ||
				   context == grammarAccess.getPropertyTypeRule()) {
					sequence_EnumerationType(context, (EnumerationType) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUnnamedEnumerationTypeRule() ||
				   context == grammarAccess.getUnnamedPropertyTypeRule()) {
					sequence_UnnamedEnumerationType(context, (EnumerationType) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.EVENT_DATA_PORT:
				sequence_EventDataPort(context, (EventDataPort) semanticObject); 
				return; 
			case Aadl2Package.EVENT_DATA_SOURCE:
				sequence_EventDataSource(context, (EventDataSource) semanticObject); 
				return; 
			case Aadl2Package.EVENT_PORT:
				sequence_EventPort(context, (EventPort) semanticObject); 
				return; 
			case Aadl2Package.EVENT_SOURCE:
				sequence_EventSource(context, (EventSource) semanticObject); 
				return; 
			case Aadl2Package.FEATURE_CONNECTION:
				sequence_FeatureConnection(context, (FeatureConnection) semanticObject); 
				return; 
			case Aadl2Package.FEATURE_GROUP:
				sequence_FeatureGroup(context, (FeatureGroup) semanticObject); 
				return; 
			case Aadl2Package.FEATURE_GROUP_CONNECTION:
				sequence_FeatureGroupConnection(context, (FeatureGroupConnection) semanticObject); 
				return; 
			case Aadl2Package.FEATURE_GROUP_PROTOTYPE:
				if(context == grammarAccess.getFeatureGroupPrototypeRule()) {
					sequence_FeatureGroupPrototype(context, (FeatureGroupPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPrototypeRule()) {
					sequence_FeatureGroupPrototype_Prototype(context, (FeatureGroupPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.FEATURE_GROUP_PROTOTYPE_ACTUAL:
				sequence_FeatureGroupPrototypeActual(context, (FeatureGroupPrototypeActual) semanticObject); 
				return; 
			case Aadl2Package.FEATURE_GROUP_PROTOTYPE_BINDING:
				sequence_FeatureGroupPrototypeBinding(context, (FeatureGroupPrototypeBinding) semanticObject); 
				return; 
			case Aadl2Package.FEATURE_GROUP_TYPE:
				sequence_FeatureGroupType(context, (FeatureGroupType) semanticObject); 
				return; 
			case Aadl2Package.FEATURE_GROUP_TYPE_RENAME:
				sequence_FGTRename(context, (FeatureGroupTypeRename) semanticObject); 
				return; 
			case Aadl2Package.FEATURE_PROTOTYPE:
				if(context == grammarAccess.getFeaturePrototypeRule()) {
					sequence_FeaturePrototype(context, (FeaturePrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPrototypeRule()) {
					sequence_FeaturePrototype_Prototype(context, (FeaturePrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.FEATURE_PROTOTYPE_BINDING:
				sequence_FeaturePrototypeBinding(context, (FeaturePrototypeBinding) semanticObject); 
				return; 
			case Aadl2Package.FEATURE_PROTOTYPE_REFERENCE:
				sequence_FeaturePrototypeReference(context, (FeaturePrototypeReference) semanticObject); 
				return; 
			case Aadl2Package.FLOW_END:
				sequence_FlowEnd(context, (FlowEnd) semanticObject); 
				return; 
			case Aadl2Package.FLOW_IMPLEMENTATION:
				if(context == grammarAccess.getFlowImplementationRule()) {
					sequence_FlowImplementation_FlowPathImpl_FlowSinkImpl_FlowSourceImpl(context, (FlowImplementation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFlowPathImplRule()) {
					sequence_FlowPathImpl(context, (FlowImplementation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFlowSinkImplRule()) {
					sequence_FlowSinkImpl(context, (FlowImplementation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFlowSourceImplRule()) {
					sequence_FlowSourceImpl(context, (FlowImplementation) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.FLOW_SEGMENT:
				if(context == grammarAccess.getConnectionFlowRule()) {
					sequence_ConnectionFlow(context, (FlowSegment) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getSubcomponentFlowRule()) {
					sequence_SubcomponentFlow(context, (FlowSegment) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.FLOW_SPECIFICATION:
				if(context == grammarAccess.getFlowSpecificationRule()) {
					sequence_FlowPathSpec_FlowSinkSpec_FlowSourceSpec_FlowSpecRefinement_FlowSpecification(context, (FlowSpecification) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFlowPathSpecRule()) {
					sequence_FlowPathSpec(context, (FlowSpecification) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFlowSinkSpecRule()) {
					sequence_FlowSinkSpec(context, (FlowSpecification) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFlowSourceSpecRule()) {
					sequence_FlowSourceSpec(context, (FlowSpecification) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFlowSpecRefinementRule()) {
					sequence_FlowSpecRefinement(context, (FlowSpecification) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.GROUP_EXTENSION:
				sequence_GroupExtension(context, (GroupExtension) semanticObject); 
				return; 
			case Aadl2Package.IMPLEMENTATION_EXTENSION:
				sequence_ImplementationExtension(context, (ImplementationExtension) semanticObject); 
				return; 
			case Aadl2Package.INTEGER_LITERAL:
				if(context == grammarAccess.getIntegerLitRule() ||
				   context == grammarAccess.getNumberValueRule()) {
					sequence_IntegerLit(context, (IntegerLiteral) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getConstantPropertyExpressionRule() ||
				   context == grammarAccess.getIntegerTermRule() ||
				   context == grammarAccess.getNumAltRule() ||
				   context == grammarAccess.getPropertyExpressionRule()) {
					sequence_IntegerTerm(context, (IntegerLiteral) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.LIST_TYPE:
				sequence_ListType(context, (ListType) semanticObject); 
				return; 
			case Aadl2Package.LIST_VALUE:
				sequence_ListTerm(context, (ListValue) semanticObject); 
				return; 
			case Aadl2Package.MEMORY_IMPLEMENTATION:
				sequence_MemoryImplementation(context, (MemoryImplementation) semanticObject); 
				return; 
			case Aadl2Package.MEMORY_PROTOTYPE:
				if(context == grammarAccess.getComponentPrototypeRule() ||
				   context == grammarAccess.getMemoryPrototypeRule()) {
					sequence_MemoryPrototype(context, (MemoryPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPrototypeRule()) {
					sequence_MemoryPrototype_Prototype(context, (MemoryPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.MEMORY_SUBCOMPONENT:
				sequence_MemorySubcomponent(context, (MemorySubcomponent) semanticObject); 
				return; 
			case Aadl2Package.MEMORY_TYPE:
				sequence_MemoryType(context, (MemoryType) semanticObject); 
				return; 
			case Aadl2Package.METACLASS_REFERENCE:
				if(context == grammarAccess.getAllReferenceRule()) {
					sequence_AllReference(context, (MetaclassReference) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPropertyOwnerRule() ||
				   context == grammarAccess.getQMReferenceRule()) {
					sequence_QMReference(context, (MetaclassReference) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.MODAL_PROPERTY_VALUE:
				if(context == grammarAccess.getModalPropertyValueRule()) {
					sequence_ModalPropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getOptionalModalPropertyValueRule()) {
					sequence_OptionalModalPropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPropertyValueRule()) {
					sequence_PropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.MODE:
				sequence_Mode(context, (Mode) semanticObject); 
				return; 
			case Aadl2Package.MODE_BINDING:
				sequence_ModeRef(context, (ModeBinding) semanticObject); 
				return; 
			case Aadl2Package.MODE_TRANSITION:
				sequence_ModeTransition(context, (ModeTransition) semanticObject); 
				return; 
			case Aadl2Package.MODE_TRANSITION_TRIGGER:
				sequence_Trigger(context, (ModeTransitionTrigger) semanticObject); 
				return; 
			case Aadl2Package.NAMED_VALUE:
				if(context == grammarAccess.getConstantValueRule() ||
				   context == grammarAccess.getNumAltRule()) {
					sequence_ConstantValue(context, (NamedValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getConstantPropertyExpressionRule() ||
				   context == grammarAccess.getLiteralorReferenceTermRule() ||
				   context == grammarAccess.getPropertyExpressionRule()) {
					sequence_LiteralorReferenceTerm(context, (NamedValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.NUMERIC_RANGE:
				if(context == grammarAccess.getIntegerRangeRule()) {
					sequence_IntegerRange(context, (NumericRange) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getRealRangeRule()) {
					sequence_RealRange(context, (NumericRange) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.OPERATION:
				sequence_SignedConstant(context, (Operation) semanticObject); 
				return; 
			case Aadl2Package.PACKAGE_RENAME:
				if(context == grammarAccess.getPackageRenameRule()) {
					sequence_PackageRename(context, (PackageRename) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getRenameAllRule()) {
					sequence_RenameAll(context, (PackageRename) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.PARAMETER:
				sequence_Parameter(context, (Parameter) semanticObject); 
				return; 
			case Aadl2Package.PARAMETER_CONNECTION:
				sequence_ParameterConnection(context, (ParameterConnection) semanticObject); 
				return; 
			case Aadl2Package.PORT_CONNECTION:
				sequence_PortConnection(context, (PortConnection) semanticObject); 
				return; 
			case Aadl2Package.PORT_PROXY:
				sequence_PortProxy(context, (PortProxy) semanticObject); 
				return; 
			case Aadl2Package.PORT_SPECIFICATION:
				sequence_PortSpecification(context, (PortSpecification) semanticObject); 
				return; 
			case Aadl2Package.PRIVATE_PACKAGE_SECTION:
				sequence_PrivatePackageSection(context, (PrivatePackageSection) semanticObject); 
				return; 
			case Aadl2Package.PROCESS_IMPLEMENTATION:
				sequence_ProcessImplementation(context, (ProcessImplementation) semanticObject); 
				return; 
			case Aadl2Package.PROCESS_PROTOTYPE:
				if(context == grammarAccess.getComponentPrototypeRule() ||
				   context == grammarAccess.getProcessPrototypeRule()) {
					sequence_ProcessPrototype(context, (ProcessPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPrototypeRule()) {
					sequence_ProcessPrototype_Prototype(context, (ProcessPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.PROCESS_SUBCOMPONENT:
				sequence_ProcessSubcomponent(context, (ProcessSubcomponent) semanticObject); 
				return; 
			case Aadl2Package.PROCESS_TYPE:
				sequence_ProcessType(context, (ProcessType) semanticObject); 
				return; 
			case Aadl2Package.PROCESSOR_IMPLEMENTATION:
				sequence_ProcessorImplementation(context, (ProcessorImplementation) semanticObject); 
				return; 
			case Aadl2Package.PROCESSOR_PROTOTYPE:
				if(context == grammarAccess.getComponentPrototypeRule() ||
				   context == grammarAccess.getProcessorPrototypeRule()) {
					sequence_ProcessorPrototype(context, (ProcessorPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPrototypeRule()) {
					sequence_ProcessorPrototype_Prototype(context, (ProcessorPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.PROCESSOR_SUBCOMPONENT:
				sequence_ProcessorSubcomponent(context, (ProcessorSubcomponent) semanticObject); 
				return; 
			case Aadl2Package.PROCESSOR_TYPE:
				sequence_ProcessorType(context, (ProcessorType) semanticObject); 
				return; 
			case Aadl2Package.PROPERTY:
				sequence_PropertyDefinition(context, (Property) semanticObject); 
				return; 
			case Aadl2Package.PROPERTY_ASSOCIATION:
				if(context == grammarAccess.getBasicPropertyAssociationRule()) {
					sequence_BasicPropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getContainedPropertyAssociationRule() ||
				   context == grammarAccess.getPModelRule()) {
					sequence_ContainedPropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPropertyAssociationRule()) {
					sequence_PropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.PROPERTY_CONSTANT:
				sequence_PropertyConstant(context, (PropertyConstant) semanticObject); 
				return; 
			case Aadl2Package.PROPERTY_SET:
				sequence_PropertySet(context, (PropertySet) semanticObject); 
				return; 
			case Aadl2Package.PUBLIC_PACKAGE_SECTION:
				sequence_PublicPackageSection(context, (PublicPackageSection) semanticObject); 
				return; 
			case Aadl2Package.RANGE_TYPE:
				if(context == grammarAccess.getPropertyTypeRule() ||
				   context == grammarAccess.getRangeTypeRule()) {
					sequence_RangeType(context, (RangeType) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUnnamedPropertyTypeRule() ||
				   context == grammarAccess.getUnnamedRangeTypeRule()) {
					sequence_UnnamedRangeType(context, (RangeType) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.RANGE_VALUE:
				sequence_NumericRangeTerm(context, (RangeValue) semanticObject); 
				return; 
			case Aadl2Package.REAL_LITERAL:
				if(context == grammarAccess.getNumberValueRule() ||
				   context == grammarAccess.getRealLitRule()) {
					sequence_RealLit(context, (RealLiteral) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getConstantPropertyExpressionRule() ||
				   context == grammarAccess.getNumAltRule() ||
				   context == grammarAccess.getPropertyExpressionRule() ||
				   context == grammarAccess.getRealTermRule()) {
					sequence_RealTerm(context, (RealLiteral) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.REALIZATION:
				sequence_Realization(context, (Realization) semanticObject); 
				return; 
			case Aadl2Package.RECORD_TYPE:
				if(context == grammarAccess.getPropertyTypeRule() ||
				   context == grammarAccess.getRecordTypeRule()) {
					sequence_RecordType(context, (RecordType) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUnnamedPropertyTypeRule() ||
				   context == grammarAccess.getUnnamedRecordTypeRule()) {
					sequence_UnnamedRecordType(context, (RecordType) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.RECORD_VALUE:
				if(context == grammarAccess.getOldRecordTermRule()) {
					sequence_OldRecordTerm(context, (RecordValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getConstantPropertyExpressionRule() ||
				   context == grammarAccess.getPropertyExpressionRule() ||
				   context == grammarAccess.getRecordTermRule()) {
					sequence_RecordTerm(context, (RecordValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.REFERENCE_TYPE:
				if(context == grammarAccess.getPropertyTypeRule() ||
				   context == grammarAccess.getReferenceTypeRule()) {
					sequence_ReferenceType(context, (ReferenceType) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUnnamedPropertyTypeRule() ||
				   context == grammarAccess.getUnnamedReferenceTypeRule()) {
					sequence_UnnamedReferenceType(context, (ReferenceType) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.REFERENCE_VALUE:
				sequence_ReferenceTerm(context, (ReferenceValue) semanticObject); 
				return; 
			case Aadl2Package.STRING_LITERAL:
				sequence_StringTerm(context, (StringLiteral) semanticObject); 
				return; 
			case Aadl2Package.SUBPROGRAM_ACCESS:
				sequence_SubprogramAccess(context, (SubprogramAccess) semanticObject); 
				return; 
			case Aadl2Package.SUBPROGRAM_CALL:
				sequence_SubprogramCall(context, (SubprogramCall) semanticObject); 
				return; 
			case Aadl2Package.SUBPROGRAM_CALL_SEQUENCE:
				sequence_SubprogramCallSequence(context, (SubprogramCallSequence) semanticObject); 
				return; 
			case Aadl2Package.SUBPROGRAM_GROUP_ACCESS:
				sequence_SubprogramGroupAccess(context, (SubprogramGroupAccess) semanticObject); 
				return; 
			case Aadl2Package.SUBPROGRAM_GROUP_IMPLEMENTATION:
				sequence_SubprogramGroupImplementation(context, (SubprogramGroupImplementation) semanticObject); 
				return; 
			case Aadl2Package.SUBPROGRAM_GROUP_PROTOTYPE:
				if(context == grammarAccess.getPrototypeRule()) {
					sequence_Prototype_SubprogramGroupPrototype(context, (SubprogramGroupPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getComponentPrototypeRule() ||
				   context == grammarAccess.getSubprogramGroupPrototypeRule()) {
					sequence_SubprogramGroupPrototype(context, (SubprogramGroupPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.SUBPROGRAM_GROUP_SUBCOMPONENT:
				sequence_SubprogramGroupSubcomponent(context, (SubprogramGroupSubcomponent) semanticObject); 
				return; 
			case Aadl2Package.SUBPROGRAM_GROUP_TYPE:
				sequence_SubprogramGroupType(context, (SubprogramGroupType) semanticObject); 
				return; 
			case Aadl2Package.SUBPROGRAM_IMPLEMENTATION:
				sequence_SubprogramImplementation(context, (SubprogramImplementation) semanticObject); 
				return; 
			case Aadl2Package.SUBPROGRAM_PROTOTYPE:
				if(context == grammarAccess.getPrototypeRule()) {
					sequence_Prototype_SubprogramPrototype(context, (SubprogramPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getComponentPrototypeRule() ||
				   context == grammarAccess.getSubprogramPrototypeRule()) {
					sequence_SubprogramPrototype(context, (SubprogramPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.SUBPROGRAM_PROXY:
				sequence_SubprogramProxy(context, (SubprogramProxy) semanticObject); 
				return; 
			case Aadl2Package.SUBPROGRAM_SUBCOMPONENT:
				sequence_SubprogramSubcomponent(context, (SubprogramSubcomponent) semanticObject); 
				return; 
			case Aadl2Package.SUBPROGRAM_TYPE:
				sequence_SubprogramType(context, (SubprogramType) semanticObject); 
				return; 
			case Aadl2Package.SYSTEM_IMPLEMENTATION:
				sequence_SystemImplementation(context, (SystemImplementation) semanticObject); 
				return; 
			case Aadl2Package.SYSTEM_PROTOTYPE:
				if(context == grammarAccess.getPrototypeRule()) {
					sequence_Prototype_SystemPrototype(context, (SystemPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getComponentPrototypeRule() ||
				   context == grammarAccess.getSystemPrototypeRule()) {
					sequence_SystemPrototype(context, (SystemPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.SYSTEM_SUBCOMPONENT:
				sequence_SystemSubcomponent(context, (SystemSubcomponent) semanticObject); 
				return; 
			case Aadl2Package.SYSTEM_TYPE:
				sequence_SystemType(context, (SystemType) semanticObject); 
				return; 
			case Aadl2Package.THREAD_GROUP_IMPLEMENTATION:
				sequence_ThreadGroupImplementation(context, (ThreadGroupImplementation) semanticObject); 
				return; 
			case Aadl2Package.THREAD_GROUP_PROTOTYPE:
				if(context == grammarAccess.getPrototypeRule()) {
					sequence_Prototype_ThreadGroupPrototype(context, (ThreadGroupPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getComponentPrototypeRule() ||
				   context == grammarAccess.getThreadGroupPrototypeRule()) {
					sequence_ThreadGroupPrototype(context, (ThreadGroupPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.THREAD_GROUP_SUBCOMPONENT:
				sequence_ThreadGroupSubcomponent(context, (ThreadGroupSubcomponent) semanticObject); 
				return; 
			case Aadl2Package.THREAD_GROUP_TYPE:
				sequence_ThreadGroupType(context, (ThreadGroupType) semanticObject); 
				return; 
			case Aadl2Package.THREAD_IMPLEMENTATION:
				sequence_ThreadImplementation(context, (ThreadImplementation) semanticObject); 
				return; 
			case Aadl2Package.THREAD_PROTOTYPE:
				if(context == grammarAccess.getPrototypeRule()) {
					sequence_Prototype_ThreadPrototype(context, (ThreadPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getComponentPrototypeRule() ||
				   context == grammarAccess.getThreadPrototypeRule()) {
					sequence_ThreadPrototype(context, (ThreadPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.THREAD_SUBCOMPONENT:
				sequence_ThreadSubcomponent(context, (ThreadSubcomponent) semanticObject); 
				return; 
			case Aadl2Package.THREAD_TYPE:
				sequence_ThreadType(context, (ThreadType) semanticObject); 
				return; 
			case Aadl2Package.TYPE_EXTENSION:
				sequence_TypeExtension(context, (TypeExtension) semanticObject); 
				return; 
			case Aadl2Package.UNIT_LITERAL:
				if(context == grammarAccess.getUnitLiteralConversionRule()) {
					sequence_UnitLiteralConversion(context, (UnitLiteral) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUnitLiteralRule()) {
					sequence_UnitLiteral(context, (UnitLiteral) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.UNITS_TYPE:
				if(context == grammarAccess.getPropertyTypeRule() ||
				   context == grammarAccess.getUnitsTypeRule()) {
					sequence_UnitsType(context, (UnitsType) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUnnamedPropertyTypeRule() ||
				   context == grammarAccess.getUnnamedUnitsTypeRule()) {
					sequence_UnnamedUnitsType(context, (UnitsType) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.VIRTUAL_BUS_IMPLEMENTATION:
				sequence_VirtualBusImplementation(context, (VirtualBusImplementation) semanticObject); 
				return; 
			case Aadl2Package.VIRTUAL_BUS_PROTOTYPE:
				if(context == grammarAccess.getPrototypeRule()) {
					sequence_Prototype_VirtualBusPrototype(context, (VirtualBusPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getComponentPrototypeRule() ||
				   context == grammarAccess.getVirtualBusPrototypeRule()) {
					sequence_VirtualBusPrototype(context, (VirtualBusPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.VIRTUAL_BUS_SUBCOMPONENT:
				sequence_VirtualBusSubcomponent(context, (VirtualBusSubcomponent) semanticObject); 
				return; 
			case Aadl2Package.VIRTUAL_BUS_TYPE:
				sequence_VirtualBusType(context, (VirtualBusType) semanticObject); 
				return; 
			case Aadl2Package.VIRTUAL_PROCESSOR_IMPLEMENTATION:
				sequence_VirtualProcessorImplementation(context, (VirtualProcessorImplementation) semanticObject); 
				return; 
			case Aadl2Package.VIRTUAL_PROCESSOR_PROTOTYPE:
				if(context == grammarAccess.getPrototypeRule()) {
					sequence_Prototype_VirtualProcessorPrototype(context, (VirtualProcessorPrototype) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getComponentPrototypeRule() ||
				   context == grammarAccess.getVirtualProcessorPrototypeRule()) {
					sequence_VirtualProcessorPrototype(context, (VirtualProcessorPrototype) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.VIRTUAL_PROCESSOR_SUBCOMPONENT:
				sequence_VirtualProcessorSubcomponent(context, (VirtualProcessorSubcomponent) semanticObject); 
				return; 
			case Aadl2Package.VIRTUAL_PROCESSOR_TYPE:
				sequence_VirtualProcessorType(context, (VirtualProcessorType) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == McsPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case McsPackage.APPLIES_TO_CLAUSE:
				sequence_AppliesToClause(context, (AppliesToClause) semanticObject); 
				return; 
			case McsPackage.CLASSIFIER_CATEGORY:
				sequence_ClassifierCategory(context, (ClassifierCategory) semanticObject); 
				return; 
			case McsPackage.CLASSIFIER_ENFORCE:
				sequence_ClassifierEnforce(context, (ClassifierEnforce) semanticObject); 
				return; 
			case McsPackage.CLASSIFIER_SCRIPT:
				sequence_ClassifierScript(context, (ClassifierScript) semanticObject); 
				return; 
			case McsPackage.CONSTRAINTS_BLOCK:
				sequence_ConstraintsBlock(context, (ConstraintsBlock) semanticObject); 
				return; 
			case McsPackage.ENFORCEMENT_POLICY:
				sequence_Enforcement_policy(context, (Enforcement_policy) semanticObject); 
				return; 
			case McsPackage.FEATURE_GROUP_CLASSIFIER_REFERENCE:
				sequence_FeatureGroupClassifierReference(context, (FeatureGroupClassifierReference) semanticObject); 
				return; 
			case McsPackage.MCS_ANNEX_LIBRARY:
				sequence_MCSAnnexLibrary(context, (MCSAnnexLibrary) semanticObject); 
				return; 
			case McsPackage.MCS_ANNEX_SUBCLAUSE:
				sequence_MCSAnnexSubclause(context, (MCSAnnexSubclause) semanticObject); 
				return; 
			case McsPackage.MCS_GRAMMAR_ROOT:
				sequence_MCSGrammarRoot(context, (MCSGrammarRoot) semanticObject); 
				return; 
			case McsPackage.MCS_VIEWPOINT:
				sequence_MCSViewpoint(context, (MCSViewpoint) semanticObject); 
				return; 
			case McsPackage.MODE_NAME:
				sequence_ModeName(context, (ModeName) semanticObject); 
				return; 
			case McsPackage.MODE_SPEC:
				sequence_ModeSpec(context, (ModeSpec) semanticObject); 
				return; 
			case McsPackage.PACKAGE_ENFORCE:
				sequence_PackageEnforce(context, (PackageEnforce) semanticObject); 
				return; 
			case McsPackage.PACKAGE_SCRIPT:
				sequence_PackageScript(context, (PackageScript) semanticObject); 
				return; 
			case McsPackage.VIEWPOINT_REFERENCE:
				sequence_ViewpointReference(context, (ViewpointReference) semanticObject); 
				return; 
			case McsPackage.ASSERTION_EXPRESSION:
				sequence_assertion_expression(context, (assertion_expression) semanticObject); 
				return; 
			case McsPackage.BASIC_TYPE:
				sequence_basic_type(context, (basic_type) semanticObject); 
				return; 
			case McsPackage.BLOCK_LABEL_ID:
				sequence_block_label_id(context, (block_label_id) semanticObject); 
				return; 
			case McsPackage.CHECK_ASSERTION:
				sequence_check_assertion(context, (check_assertion) semanticObject); 
				return; 
			case McsPackage.CHECK_LABEL_ID:
				sequence_check_label_id(context, (check_label_id) semanticObject); 
				return; 
			case McsPackage.CHECK_THEOREM:
				sequence_check_theorem(context, (check_theorem) semanticObject); 
				return; 
			case McsPackage.CONSTANT_IDENTIFIER:
				if(context == grammarAccess.getConstant_declarationRule() ||
				   context == grammarAccess.getLocal_declarationRule()) {
					sequence_constant_declaration_constant_identifier(context, (constant_identifier) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getConstant_identifierRule()) {
					sequence_constant_identifier(context, (constant_identifier) semanticObject); 
					return; 
				}
				else break;
			case McsPackage.ELEMENT_REFERENCE:
				sequence_element_reference(context, (element_reference) semanticObject); 
				return; 
			case McsPackage.EXPRESSION:
				sequence_expression(context, (expression) semanticObject); 
				return; 
			case McsPackage.IN_MODES_LIST:
				sequence_in_modes_list(context, (in_modes_list) semanticObject); 
				return; 
			case McsPackage.LABELLED_CHECK_STATEMENT:
				sequence_labelled_check_statement(context, (labelled_check_statement) semanticObject); 
				return; 
			case McsPackage.STRING_EXPRESSION:
				sequence_string_expression(context, (string_expression) semanticObject); 
				return; 
			case McsPackage.THEOREM_DECLARATION:
				sequence_theorem_declaration(context, (theorem_declaration) semanticObject); 
				return; 
			case McsPackage.THEOREM_STATEMENTS:
				sequence_theorem_statements(context, (theorem_statements) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (all?='all' | category=ClassifierCategory)
	 */
	protected void sequence_AppliesToClause(EObject context, AppliesToClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (component=ComponentCategory ct=[ComponentType|QCREF]? (impl?='implementation' ci=[ComponentImplementation|QCREF]?)?) | 
	 *         (feat_g?='feature group' ref_to_f=FeatureGroupClassifierReference?)
	 *     )
	 */
	protected void sequence_ClassifierCategory(EObject context, ClassifierCategory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (viewpoint=[MCSViewpoint|ID] script=ClassifierScript)
	 */
	protected void sequence_ClassifierEnforce(EObject context, ClassifierEnforce semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.CLASSIFIER_ENFORCE__VIEWPOINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.CLASSIFIER_ENFORCE__VIEWPOINT));
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.CLASSIFIER_ENFORCE__SCRIPT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.CLASSIFIER_ENFORCE__SCRIPT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getClassifierEnforceAccess().getViewpointMCSViewpointIDTerminalRuleCall_1_0_1(), semanticObject.getViewpoint());
		feeder.accept(grammarAccess.getClassifierEnforceAccess().getScriptClassifierScriptParserRuleCall_2_0(), semanticObject.getScript());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (c_block+=ConstraintsBlock* ref=ViewpointReference)
	 */
	protected void sequence_ClassifierScript(EObject context, ClassifierScript semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (b_label=block_label_id? cs+=labelled_check_statement+)
	 */
	protected void sequence_ConstraintsBlock(EObject context, ConstraintsBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (pack?='package' | class?='classifier')
	 */
	protected void sequence_Enforcement_policy(EObject context, Enforcement_policy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     fg=[FeatureGroupType|QCREF]
	 */
	protected void sequence_FeatureGroupClassifierReference(EObject context, FeatureGroupClassifierReference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.FEATURE_GROUP_CLASSIFIER_REFERENCE__FG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.FEATURE_GROUP_CLASSIFIER_REFERENCE__FG));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFeatureGroupClassifierReferenceAccess().getFgFeatureGroupTypeQCREFParserRuleCall_0_1(), semanticObject.getFg());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         theorems+=theorem_declaration+ 
	 *         (viewpoints+=MCSViewpoint viewpoints+=MCSViewpoint*)? 
	 *         (enforceclauses+=PackageEnforce enforceclauses+=PackageEnforce*)?
	 *     )
	 */
	protected void sequence_MCSAnnexLibrary(EObject context, MCSAnnexLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (theorems+=theorem_declaration+ (enforceclauses+=ClassifierEnforce enforceclauses+=ClassifierEnforce*)?)
	 */
	protected void sequence_MCSAnnexSubclause(EObject context, MCSAnnexSubclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (lib=MCSAnnexLibrary | subclause=MCSAnnexSubclause)
	 */
	protected void sequence_MCSGrammarRoot(EObject context, MCSGrammarRoot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID policy=Enforcement_policy pscript=PackageScript?)
	 */
	protected void sequence_MCSViewpoint(EObject context, MCSViewpoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ModeName(EObject context, ModeName semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.MODE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.MODE_NAME__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getModeNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     mode=ModeName
	 */
	protected void sequence_ModeSpec(EObject context, ModeSpec semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.MODE_SPEC__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.MODE_SPEC__MODE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getModeSpecAccess().getModeModeNameParserRuleCall_2_0(), semanticObject.getMode());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     viewpoint=[MCSViewpoint|ID]
	 */
	protected void sequence_PackageEnforce(EObject context, PackageEnforce semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.PACKAGE_ENFORCE__VIEWPOINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.PACKAGE_ENFORCE__VIEWPOINT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPackageEnforceAccess().getViewpointMCSViewpointIDTerminalRuleCall_1_0_1(), semanticObject.getViewpoint());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((applies+=AppliesToClause c_block+=ConstraintsBlock+)* ref=ViewpointReference)
	 */
	protected void sequence_PackageScript(EObject context, PackageScript semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (policy=[Enforcement_policy|ID]? vp_ref=[MCSViewpoint|ID])
	 */
	protected void sequence_ViewpointReference(EObject context, ViewpointReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expr=expression
	 */
	protected void sequence_assertion_expression(EObject context, assertion_expression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.ASSERTION_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.ASSERTION_EXPRESSION__EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssertion_expressionAccess().getExprExpressionParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (bool=BooleanType | string=StringType)
	 */
	protected void sequence_basic_type(EObject context, basic_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_block_label_id(EObject context, block_label_id semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.BLOCK_LABEL_ID__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.BLOCK_LABEL_ID__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBlock_label_idAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (root=root_element? inmode=ModeSpec? expr=assertion_expression str=string_expression?)
	 */
	protected void sequence_check_assertion(EObject context, check_assertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_check_label_id(EObject context, check_label_id semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.CHECK_LABEL_ID__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.CHECK_LABEL_ID__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCheck_label_idAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (theo=[theorem_declaration|ID] root=root_element? inmode=ModeSpec? str=string_expression?)
	 */
	protected void sequence_check_theorem(EObject context, check_theorem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=type_expression? left_expr=constant_expression)
	 */
	protected void sequence_constant_declaration_constant_identifier(EObject context, constant_identifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_constant_identifier(EObject context, constant_identifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_element_reference(EObject context, element_reference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.ELEMENT_REFERENCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.ELEMENT_REFERENCE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getElement_referenceAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expr=PropertyExpression
	 */
	protected void sequence_expression(EObject context, expression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.EXPRESSION__EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpressionAccess().getExprPropertyExpressionParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     modes+=ID+
	 */
	protected void sequence_in_modes_list(EObject context, in_modes_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (c_label=check_label_id? cs=check_statement)
	 */
	protected void sequence_labelled_check_statement(EObject context, labelled_check_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expr=expression
	 */
	protected void sequence_string_expression(EObject context, string_expression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.STRING_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.STRING_EXPRESSION__EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getString_expressionAccess().getExprExpressionParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID ml?=in_modes_list? locals+=local_declaration* statements+=theorem_statements* endname=ID)
	 */
	protected void sequence_theorem_declaration(EObject context, theorem_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     statements='statements'
	 */
	protected void sequence_theorem_statements(EObject context, theorem_statements semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.THEOREM_STATEMENTS__STATEMENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.THEOREM_STATEMENTS__STATEMENTS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTheorem_statementsAccess().getStatementsStatementsKeyword_0(), semanticObject.getStatements());
		feeder.finish();
	}
}
