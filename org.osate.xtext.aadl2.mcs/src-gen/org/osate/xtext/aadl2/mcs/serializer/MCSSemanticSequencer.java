/*
 * generated by Xtext
 */
package org.osate.xtext.aadl2.mcs.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.osate.aadl2.Aadl2Package;
import org.osate.aadl2.AadlBoolean;
import org.osate.aadl2.AadlString;
import org.osate.aadl2.ArrayRange;
import org.osate.aadl2.BasicPropertyAssociation;
import org.osate.aadl2.BooleanLiteral;
import org.osate.aadl2.ClassifierValue;
import org.osate.aadl2.ComputedValue;
import org.osate.aadl2.ContainedNamedElement;
import org.osate.aadl2.ContainmentPathElement;
import org.osate.aadl2.EnumerationLiteral;
import org.osate.aadl2.EnumerationType;
import org.osate.aadl2.IntegerLiteral;
import org.osate.aadl2.ListValue;
import org.osate.aadl2.ModalPropertyValue;
import org.osate.aadl2.NamedValue;
import org.osate.aadl2.Operation;
import org.osate.aadl2.PropertyAssociation;
import org.osate.aadl2.RangeValue;
import org.osate.aadl2.RealLiteral;
import org.osate.aadl2.RecordValue;
import org.osate.aadl2.ReferenceValue;
import org.osate.aadl2.StringLiteral;
import org.osate.aadl2.UnitLiteral;
import org.osate.aadl2.UnitsType;
import org.osate.xtext.aadl2.mcs.mcs.Basic_type;
import org.osate.xtext.aadl2.mcs.mcs.BinaryExpr;
import org.osate.xtext.aadl2.mcs.mcs.BoolExpr;
import org.osate.xtext.aadl2.mcs.mcs.BuiltInFnCall;
import org.osate.xtext.aadl2.mcs.mcs.BuiltInFnCallExpr;
import org.osate.xtext.aadl2.mcs.mcs.ClaimArg;
import org.osate.xtext.aadl2.mcs.mcs.ClaimString;
import org.osate.xtext.aadl2.mcs.mcs.Classifier_literal;
import org.osate.xtext.aadl2.mcs.mcs.Classifiers;
import org.osate.xtext.aadl2.mcs.mcs.CompExpr;
import org.osate.xtext.aadl2.mcs.mcs.Constant_declaration;
import org.osate.xtext.aadl2.mcs.mcs.Element_type;
import org.osate.xtext.aadl2.mcs.mcs.EmptySetExpr;
import org.osate.xtext.aadl2.mcs.mcs.FilterMapExpr;
import org.osate.xtext.aadl2.mcs.mcs.FilterSet;
import org.osate.xtext.aadl2.mcs.mcs.FnCall;
import org.osate.xtext.aadl2.mcs.mcs.FnCallExpr;
import org.osate.xtext.aadl2.mcs.mcs.Function;
import org.osate.xtext.aadl2.mcs.mcs.FunctionBody;
import org.osate.xtext.aadl2.mcs.mcs.IfThenElseExpr;
import org.osate.xtext.aadl2.mcs.mcs.InstanceOfExpr;
import org.osate.xtext.aadl2.mcs.mcs.Instances;
import org.osate.xtext.aadl2.mcs.mcs.IntExpr;
import org.osate.xtext.aadl2.mcs.mcs.IntegerRange;
import org.osate.xtext.aadl2.mcs.mcs.LetExpr;
import org.osate.xtext.aadl2.mcs.mcs.List_type;
import org.osate.xtext.aadl2.mcs.mcs.MCSAnnexLibrary;
import org.osate.xtext.aadl2.mcs.mcs.MCSAnnexSubclause;
import org.osate.xtext.aadl2.mcs.mcs.MCSFile;
import org.osate.xtext.aadl2.mcs.mcs.MCSGrammarRoot;
import org.osate.xtext.aadl2.mcs.mcs.MCSNameExpr;
import org.osate.xtext.aadl2.mcs.mcs.MappingExpr;
import org.osate.xtext.aadl2.mcs.mcs.Mapping_type;
import org.osate.xtext.aadl2.mcs.mcs.McsPackage;
import org.osate.xtext.aadl2.mcs.mcs.McsTypedName;
import org.osate.xtext.aadl2.mcs.mcs.Mcs_name_ref;
import org.osate.xtext.aadl2.mcs.mcs.MethodChain;
import org.osate.xtext.aadl2.mcs.mcs.NestedDotID;
import org.osate.xtext.aadl2.mcs.mcs.ParameterizedString;
import org.osate.xtext.aadl2.mcs.mcs.PkgExpr;
import org.osate.xtext.aadl2.mcs.mcs.PostCastExpr;
import org.osate.xtext.aadl2.mcs.mcs.QuantifiedExpr;
import org.osate.xtext.aadl2.mcs.mcs.Range;
import org.osate.xtext.aadl2.mcs.mcs.RealExpr;
import org.osate.xtext.aadl2.mcs.mcs.RealRange;
import org.osate.xtext.aadl2.mcs.mcs.RefExpr;
import org.osate.xtext.aadl2.mcs.mcs.RefTerm;
import org.osate.xtext.aadl2.mcs.mcs.SetExpr;
import org.osate.xtext.aadl2.mcs.mcs.Set_type;
import org.osate.xtext.aadl2.mcs.mcs.StringExpr;
import org.osate.xtext.aadl2.mcs.mcs.T_classifier_subtypes;
import org.osate.xtext.aadl2.mcs.mcs.Theorem;
import org.osate.xtext.aadl2.mcs.mcs.TheoremBody;
import org.osate.xtext.aadl2.mcs.mcs.TheoremCall;
import org.osate.xtext.aadl2.mcs.mcs.TheoremCallExpr;
import org.osate.xtext.aadl2.mcs.mcs.Theorem_root;
import org.osate.xtext.aadl2.mcs.mcs.ThisExpr;
import org.osate.xtext.aadl2.mcs.mcs.Type_declaration;
import org.osate.xtext.aadl2.mcs.mcs.Type_expression;
import org.osate.xtext.aadl2.mcs.mcs.UnaryExpr;
import org.osate.xtext.aadl2.mcs.mcs.Union_type;
import org.osate.xtext.aadl2.mcs.mcs.UnnamedIntegerType;
import org.osate.xtext.aadl2.mcs.mcs.UnnamedRangeType;
import org.osate.xtext.aadl2.mcs.mcs.UnnamedRealType;
import org.osate.xtext.aadl2.mcs.mcs.t_access_subtypes;
import org.osate.xtext.aadl2.mcs.mcs.t_component_subtypes;
import org.osate.xtext.aadl2.mcs.mcs.t_connection_subtypes;
import org.osate.xtext.aadl2.mcs.mcs.t_feature_subtypes;
import org.osate.xtext.aadl2.mcs.mcs.t_flow_impl_subtypes;
import org.osate.xtext.aadl2.mcs.mcs.t_flow_spec_subtypes;
import org.osate.xtext.aadl2.mcs.mcs.t_instance_subtypes;
import org.osate.xtext.aadl2.mcs.mcs.t_port_subtypes;
import org.osate.xtext.aadl2.mcs.mcs.t_subcomponent_subtypes;
import org.osate.xtext.aadl2.mcs.services.MCSGrammarAccess;
import org.osate.xtext.aadl2.properties.serializer.PropertiesSemanticSequencer;

@SuppressWarnings("all")
public class MCSSemanticSequencer extends PropertiesSemanticSequencer {

	@Inject
	private MCSGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == Aadl2Package.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case Aadl2Package.AADL_BOOLEAN:
				sequence_UnnamedBooleanType(context, (AadlBoolean) semanticObject); 
				return; 
			case Aadl2Package.AADL_STRING:
				sequence_UnnamedStringType(context, (AadlString) semanticObject); 
				return; 
			case Aadl2Package.ENUMERATION_LITERAL:
				sequence_EnumerationLiteral(context, (EnumerationLiteral) semanticObject); 
				return; 
			case Aadl2Package.ENUMERATION_TYPE:
				sequence_UnnamedEnumerationType(context, (EnumerationType) semanticObject); 
				return; 
			case Aadl2Package.INTEGER_LITERAL:
				if(context == grammarAccess.getIntegerLitRule() ||
				   context == grammarAccess.getNumberValueRule()) {
					sequence_IntegerLit(context, (IntegerLiteral) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getIntegerTermRule() ||
				   context == grammarAccess.getNumAltRule() ||
				   context == grammarAccess.getPropertyExpressionRule()) {
					sequence_IntegerTerm(context, (IntegerLiteral) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.REAL_LITERAL:
				if(context == grammarAccess.getNumberValueRule() ||
				   context == grammarAccess.getRealLitRule()) {
					sequence_RealLit(context, (RealLiteral) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNumAltRule() ||
				   context == grammarAccess.getPropertyExpressionRule() ||
				   context == grammarAccess.getRealTermRule()) {
					sequence_RealTerm(context, (RealLiteral) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.UNIT_LITERAL:
				if(context == grammarAccess.getUnitLiteralConversionRule()) {
					sequence_UnitLiteralConversion(context, (UnitLiteral) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUnitLiteralRule()) {
					sequence_UnitLiteral(context, (UnitLiteral) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.UNITS_TYPE:
				sequence_UnnamedUnitsType(context, (UnitsType) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == Aadl2Package.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case Aadl2Package.ARRAY_RANGE:
				sequence_ArrayRange(context, (ArrayRange) semanticObject); 
				return; 
			case Aadl2Package.BASIC_PROPERTY_ASSOCIATION:
				sequence_FieldPropertyAssociation(context, (BasicPropertyAssociation) semanticObject); 
				return; 
			case Aadl2Package.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case Aadl2Package.CLASSIFIER_VALUE:
				sequence_ComponentClassifierTerm(context, (ClassifierValue) semanticObject); 
				return; 
			case Aadl2Package.COMPUTED_VALUE:
				sequence_ComputedTerm(context, (ComputedValue) semanticObject); 
				return; 
			case Aadl2Package.CONTAINED_NAMED_ELEMENT:
				sequence_ContainmentPath(context, (ContainedNamedElement) semanticObject); 
				return; 
			case Aadl2Package.CONTAINMENT_PATH_ELEMENT:
				sequence_ContainmentPathElement(context, (ContainmentPathElement) semanticObject); 
				return; 
			case Aadl2Package.LIST_VALUE:
				sequence_ListTerm(context, (ListValue) semanticObject); 
				return; 
			case Aadl2Package.MODAL_PROPERTY_VALUE:
				if(context == grammarAccess.getModalPropertyValueRule()) {
					sequence_ModalPropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getOptionalModalPropertyValueRule()) {
					sequence_OptionalModalPropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPropertyValueRule()) {
					sequence_PropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.NAMED_VALUE:
				if(context == grammarAccess.getConstantValueRule() ||
				   context == grammarAccess.getNumAltRule()) {
					sequence_ConstantValue(context, (NamedValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getLiteralorReferenceTermRule() ||
				   context == grammarAccess.getPropertyExpressionRule()) {
					sequence_LiteralorReferenceTerm(context, (NamedValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.OPERATION:
				sequence_SignedConstant(context, (Operation) semanticObject); 
				return; 
			case Aadl2Package.PROPERTY_ASSOCIATION:
				if(context == grammarAccess.getBasicPropertyAssociationRule()) {
					sequence_BasicPropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getContainedPropertyAssociationRule() ||
				   context == grammarAccess.getPModelRule()) {
					sequence_ContainedPropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPropertyAssociationRule()) {
					sequence_PropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.RANGE_VALUE:
				sequence_NumericRangeTerm(context, (RangeValue) semanticObject); 
				return; 
			case Aadl2Package.RECORD_VALUE:
				if(context == grammarAccess.getOldRecordTermRule()) {
					sequence_OldRecordTerm(context, (RecordValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPropertyExpressionRule() ||
				   context == grammarAccess.getRecordTermRule()) {
					sequence_RecordTerm(context, (RecordValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.REFERENCE_VALUE:
				sequence_ReferenceTerm(context, (ReferenceValue) semanticObject); 
				return; 
			case Aadl2Package.STRING_LITERAL:
				sequence_StringTerm(context, (StringLiteral) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == McsPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case McsPackage.BASIC_TYPE:
				sequence_Basic_type(context, (Basic_type) semanticObject); 
				return; 
			case McsPackage.BINARY_EXPR:
				if(context == grammarAccess.getExprRule() ||
				   context == grammarAccess.getExpression_termRule() ||
				   context == grammarAccess.getFailExprRule()) {
					sequence_AndExpr_FailExpr_ImpliesExpr_OrExpr_PlusExpr_RelationalExpr_TimesExpr(context, (BinaryExpr) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFailExprAccess().getBinaryExprLeftAction_1_0_0_0() ||
				   context == grammarAccess.getImpliesExprRule()) {
					sequence_AndExpr_ImpliesExpr_OrExpr_PlusExpr_RelationalExpr_TimesExpr(context, (BinaryExpr) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getImpliesExprAccess().getBinaryExprLeftAction_1_0_0_0() ||
				   context == grammarAccess.getOrExprRule() ||
				   context == grammarAccess.getOrExprAccess().getBinaryExprLeftAction_1_0_0_0()) {
					sequence_AndExpr_OrExpr_PlusExpr_RelationalExpr_TimesExpr(context, (BinaryExpr) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAndExprRule() ||
				   context == grammarAccess.getAndExprAccess().getBinaryExprLeftAction_1_0_0_0()) {
					sequence_AndExpr_PlusExpr_RelationalExpr_TimesExpr(context, (BinaryExpr) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInstanceOfExprRule() ||
				   context == grammarAccess.getInstanceOfExprAccess().getInstanceOfExprExprAction_1_0_0_0() ||
				   context == grammarAccess.getRelationalExprRule()) {
					sequence_PlusExpr_RelationalExpr_TimesExpr(context, (BinaryExpr) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPlusExprRule() ||
				   context == grammarAccess.getPlusExprAccess().getBinaryExprLeftAction_1_0_0_0() ||
				   context == grammarAccess.getRelationalExprAccess().getBinaryExprLeftAction_1_0_0_0()) {
					sequence_PlusExpr_TimesExpr(context, (BinaryExpr) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getTimesExprRule() ||
				   context == grammarAccess.getTimesExprAccess().getBinaryExprLeftAction_1_0_0_0()) {
					sequence_TimesExpr(context, (BinaryExpr) semanticObject); 
					return; 
				}
				else break;
			case McsPackage.BOOL_EXPR:
				sequence_Expression_term(context, (BoolExpr) semanticObject); 
				return; 
			case McsPackage.BUILT_IN_FN_CALL:
				sequence_BuiltInFnCall(context, (BuiltInFnCall) semanticObject); 
				return; 
			case McsPackage.BUILT_IN_FN_CALL_EXPR:
				sequence_Expression_term(context, (BuiltInFnCallExpr) semanticObject); 
				return; 
			case McsPackage.CLAIM_ARG:
				sequence_TextParm(context, (ClaimArg) semanticObject); 
				return; 
			case McsPackage.CLAIM_STRING:
				sequence_TextParm(context, (ClaimString) semanticObject); 
				return; 
			case McsPackage.CLASSIFIER_LITERAL:
				sequence_Classifier_literal(context, (Classifier_literal) semanticObject); 
				return; 
			case McsPackage.CLASSIFIERS:
				sequence_Classifiers(context, (Classifiers) semanticObject); 
				return; 
			case McsPackage.COMP_EXPR:
				sequence_Expression_term(context, (CompExpr) semanticObject); 
				return; 
			case McsPackage.CONSTANT_DECLARATION:
				sequence_Constant_declaration(context, (Constant_declaration) semanticObject); 
				return; 
			case McsPackage.ELEMENT_TYPE:
				sequence_Element_type(context, (Element_type) semanticObject); 
				return; 
			case McsPackage.EMPTY_SET_EXPR:
				sequence_Expression_term(context, (EmptySetExpr) semanticObject); 
				return; 
			case McsPackage.FILTER_MAP_EXPR:
				sequence_Expression_term(context, (FilterMapExpr) semanticObject); 
				return; 
			case McsPackage.FILTER_SET:
				sequence_Expression_term_FilterMapExpr_15_4_0_0_SetExpr_15_4_1_0(context, (FilterSet) semanticObject); 
				return; 
			case McsPackage.FN_CALL:
				sequence_FnCall(context, (FnCall) semanticObject); 
				return; 
			case McsPackage.FN_CALL_EXPR:
				sequence_Expression_term(context, (FnCallExpr) semanticObject); 
				return; 
			case McsPackage.FUNCTION:
				sequence_Function_declaration(context, (Function) semanticObject); 
				return; 
			case McsPackage.FUNCTION_BODY:
				sequence_FunctionBody(context, (FunctionBody) semanticObject); 
				return; 
			case McsPackage.IF_THEN_ELSE_EXPR:
				sequence_Expression_term(context, (IfThenElseExpr) semanticObject); 
				return; 
			case McsPackage.INSTANCE_OF_EXPR:
				sequence_InstanceOfExpr(context, (InstanceOfExpr) semanticObject); 
				return; 
			case McsPackage.INSTANCES:
				sequence_Instances(context, (Instances) semanticObject); 
				return; 
			case McsPackage.INT_EXPR:
				sequence_Expression_term(context, (IntExpr) semanticObject); 
				return; 
			case McsPackage.INTEGER_RANGE:
				sequence_IntegerRange(context, (IntegerRange) semanticObject); 
				return; 
			case McsPackage.LET_EXPR:
				sequence_Expression_term(context, (LetExpr) semanticObject); 
				return; 
			case McsPackage.LIST_TYPE:
				sequence_List_type(context, (List_type) semanticObject); 
				return; 
			case McsPackage.MCS_ANNEX_LIBRARY:
				sequence_MCSAnnexLibrary(context, (MCSAnnexLibrary) semanticObject); 
				return; 
			case McsPackage.MCS_ANNEX_SUBCLAUSE:
				sequence_MCSAnnexSubclause(context, (MCSAnnexSubclause) semanticObject); 
				return; 
			case McsPackage.MCS_FILE:
				sequence_MCSFile(context, (MCSFile) semanticObject); 
				return; 
			case McsPackage.MCS_GRAMMAR_ROOT:
				sequence_MCSGrammarRoot(context, (MCSGrammarRoot) semanticObject); 
				return; 
			case McsPackage.MCS_NAME_EXPR:
				sequence_MCSNameExpr(context, (MCSNameExpr) semanticObject); 
				return; 
			case McsPackage.MAPPING_EXPR:
				sequence_Expression_term(context, (MappingExpr) semanticObject); 
				return; 
			case McsPackage.MAPPING_TYPE:
				sequence_Mapping_type(context, (Mapping_type) semanticObject); 
				return; 
			case McsPackage.MCS_TYPED_NAME:
				sequence_McsTypedName(context, (McsTypedName) semanticObject); 
				return; 
			case McsPackage.MCS_NAME_REF:
				sequence_Mcs_name_ref(context, (Mcs_name_ref) semanticObject); 
				return; 
			case McsPackage.METHOD_CHAIN:
				sequence_MethodChain(context, (MethodChain) semanticObject); 
				return; 
			case McsPackage.NESTED_DOT_ID:
				sequence_NestedDotID(context, (NestedDotID) semanticObject); 
				return; 
			case McsPackage.PARAMETERIZED_STRING:
				sequence_ParameterizedString(context, (ParameterizedString) semanticObject); 
				return; 
			case McsPackage.PKG_EXPR:
				sequence_Expression_term(context, (PkgExpr) semanticObject); 
				return; 
			case McsPackage.POST_CAST_EXPR:
				sequence_PostCastExpr(context, (PostCastExpr) semanticObject); 
				return; 
			case McsPackage.QUANTIFIED_EXPR:
				sequence_Expression_term(context, (QuantifiedExpr) semanticObject); 
				return; 
			case McsPackage.RANGE:
				if(context == grammarAccess.getExpression_termRule()) {
					sequence_Expression_term(context, (Range) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getRangeRule()) {
					sequence_Range(context, (Range) semanticObject); 
					return; 
				}
				else break;
			case McsPackage.REAL_EXPR:
				sequence_Expression_term(context, (RealExpr) semanticObject); 
				return; 
			case McsPackage.REAL_RANGE:
				sequence_RealRange(context, (RealRange) semanticObject); 
				return; 
			case McsPackage.REF_EXPR:
				sequence_Expression_term(context, (RefExpr) semanticObject); 
				return; 
			case McsPackage.REF_TERM:
				sequence_RefTerm(context, (RefTerm) semanticObject); 
				return; 
			case McsPackage.SET_EXPR:
				sequence_Expression_term(context, (SetExpr) semanticObject); 
				return; 
			case McsPackage.SET_TYPE:
				sequence_Set_type(context, (Set_type) semanticObject); 
				return; 
			case McsPackage.STRING_EXPR:
				sequence_Expression_term(context, (StringExpr) semanticObject); 
				return; 
			case McsPackage.TCLASSIFIER_SUBTYPES:
				sequence_T_classifier_subtypes(context, (T_classifier_subtypes) semanticObject); 
				return; 
			case McsPackage.THEOREM:
				sequence_Theorem_declaration(context, (Theorem) semanticObject); 
				return; 
			case McsPackage.THEOREM_BODY:
				sequence_TheoremBody(context, (TheoremBody) semanticObject); 
				return; 
			case McsPackage.THEOREM_CALL:
				sequence_Theorem_call(context, (TheoremCall) semanticObject); 
				return; 
			case McsPackage.THEOREM_CALL_EXPR:
				sequence_Expression_term(context, (TheoremCallExpr) semanticObject); 
				return; 
			case McsPackage.THEOREM_ROOT:
				sequence_Theorem_root(context, (Theorem_root) semanticObject); 
				return; 
			case McsPackage.THIS_EXPR:
				sequence_Expression_term(context, (ThisExpr) semanticObject); 
				return; 
			case McsPackage.TYPE_DECLARATION:
				sequence_Type_declaration(context, (Type_declaration) semanticObject); 
				return; 
			case McsPackage.TYPE_EXPRESSION:
				sequence_Type_expression(context, (Type_expression) semanticObject); 
				return; 
			case McsPackage.UNARY_EXPR:
				sequence_PrefixExpr(context, (UnaryExpr) semanticObject); 
				return; 
			case McsPackage.UNION_TYPE:
				sequence_Union_type(context, (Union_type) semanticObject); 
				return; 
			case McsPackage.UNNAMED_INTEGER_TYPE:
				sequence_UnnamedIntegerType(context, (UnnamedIntegerType) semanticObject); 
				return; 
			case McsPackage.UNNAMED_RANGE_TYPE:
				sequence_UnnamedRangeType(context, (UnnamedRangeType) semanticObject); 
				return; 
			case McsPackage.UNNAMED_REAL_TYPE:
				sequence_UnnamedRealType(context, (UnnamedRealType) semanticObject); 
				return; 
			case McsPackage.TACCESS_SUBTYPES:
				sequence_t_access_subtypes(context, (t_access_subtypes) semanticObject); 
				return; 
			case McsPackage.TCOMPONENT_SUBTYPES:
				sequence_t_component_subtypes(context, (t_component_subtypes) semanticObject); 
				return; 
			case McsPackage.TCONNECTION_SUBTYPES:
				sequence_t_connection_subtypes(context, (t_connection_subtypes) semanticObject); 
				return; 
			case McsPackage.TFEATURE_SUBTYPES:
				sequence_t_feature_subtypes(context, (t_feature_subtypes) semanticObject); 
				return; 
			case McsPackage.TFLOW_IMPL_SUBTYPES:
				sequence_t_flow_impl_subtypes(context, (t_flow_impl_subtypes) semanticObject); 
				return; 
			case McsPackage.TFLOW_SPEC_SUBTYPES:
				sequence_t_flow_spec_subtypes(context, (t_flow_spec_subtypes) semanticObject); 
				return; 
			case McsPackage.TINSTANCE_SUBTYPES:
				sequence_t_instance_subtypes(context, (t_instance_subtypes) semanticObject); 
				return; 
			case McsPackage.TPORT_SUBTYPES:
				sequence_t_port_subtypes(context, (t_port_subtypes) semanticObject); 
				return; 
			case McsPackage.TSUBCOMPONENT_SUBTYPES:
				sequence_t_subcomponent_subtypes(context, (t_subcomponent_subtypes) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         (left=PlusExpr_BinaryExpr_1_0_0_0 (op='+' | op='-') right=TimesExpr) | 
	 *         (left=TimesExpr_BinaryExpr_1_0_0_0 (op='*' | op='/' | op='%') right=PrefixExpr) | 
	 *         (left=RelationalExpr_BinaryExpr_1_0_0_0 op=RelationalOp right=PlusExpr) | 
	 *         (left=AndExpr_BinaryExpr_1_0_0_0 (op='and' | op='andthen') right=InstanceOfExpr) | 
	 *         (left=OrExpr_BinaryExpr_1_0_0_0 op='or' right=AndExpr) | 
	 *         (left=ImpliesExpr_BinaryExpr_1_0_0_0 op='=>' right=ImpliesExpr) | 
	 *         (left=FailExpr_BinaryExpr_1_0_0_0 op='fail' right=ParameterizedString)
	 *     )
	 */
	protected void sequence_AndExpr_FailExpr_ImpliesExpr_OrExpr_PlusExpr_RelationalExpr_TimesExpr(EObject context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (left=PlusExpr_BinaryExpr_1_0_0_0 (op='+' | op='-') right=TimesExpr) | 
	 *         (left=TimesExpr_BinaryExpr_1_0_0_0 (op='*' | op='/' | op='%') right=PrefixExpr) | 
	 *         (left=RelationalExpr_BinaryExpr_1_0_0_0 op=RelationalOp right=PlusExpr) | 
	 *         (left=AndExpr_BinaryExpr_1_0_0_0 (op='and' | op='andthen') right=InstanceOfExpr) | 
	 *         (left=OrExpr_BinaryExpr_1_0_0_0 op='or' right=AndExpr) | 
	 *         (left=ImpliesExpr_BinaryExpr_1_0_0_0 op='=>' right=ImpliesExpr)
	 *     )
	 */
	protected void sequence_AndExpr_ImpliesExpr_OrExpr_PlusExpr_RelationalExpr_TimesExpr(EObject context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (left=PlusExpr_BinaryExpr_1_0_0_0 (op='+' | op='-') right=TimesExpr) | 
	 *         (left=TimesExpr_BinaryExpr_1_0_0_0 (op='*' | op='/' | op='%') right=PrefixExpr) | 
	 *         (left=RelationalExpr_BinaryExpr_1_0_0_0 op=RelationalOp right=PlusExpr) | 
	 *         (left=AndExpr_BinaryExpr_1_0_0_0 (op='and' | op='andthen') right=InstanceOfExpr) | 
	 *         (left=OrExpr_BinaryExpr_1_0_0_0 op='or' right=AndExpr)
	 *     )
	 */
	protected void sequence_AndExpr_OrExpr_PlusExpr_RelationalExpr_TimesExpr(EObject context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (left=PlusExpr_BinaryExpr_1_0_0_0 (op='+' | op='-') right=TimesExpr) | 
	 *         (left=TimesExpr_BinaryExpr_1_0_0_0 (op='*' | op='/' | op='%') right=PrefixExpr) | 
	 *         (left=RelationalExpr_BinaryExpr_1_0_0_0 op=RelationalOp right=PlusExpr) | 
	 *         (left=AndExpr_BinaryExpr_1_0_0_0 (op='and' | op='andthen') right=InstanceOfExpr)
	 *     )
	 */
	protected void sequence_AndExpr_PlusExpr_RelationalExpr_TimesExpr(EObject context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         ptype='property_type' | 
	 *         pref='property_ref' | 
	 *         bool=UnnamedBooleanType | 
	 *         string=UnnamedStringType | 
	 *         enumer=UnnamedEnumerationType | 
	 *         units=UnnamedUnitsType | 
	 *         integer=UnnamedIntegerType | 
	 *         real=UnnamedRealType | 
	 *         range=UnnamedRangeType | 
	 *         typename=[Type_declaration|ID]
	 *     )
	 */
	protected void sequence_Basic_type(EObject context, Basic_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (fn=BuiltInFn (args+=Expr args+=Expr*)? newtype=Type_expression?)
	 */
	protected void sequence_BuiltInFnCall(EObject context, BuiltInFnCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (classlit=[ComponentClassifier|FQCREF] | nameref=Mcs_name_ref)
	 */
	protected void sequence_Classifier_literal(EObject context, Classifier_literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (t_class?='T_Classifier' | t_class_subtype?=T_classifier_subtypes)
	 */
	protected void sequence_Classifiers(EObject context, Classifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (const=McsTypedName left_expr=Expr)
	 */
	protected void sequence_Constant_declaration(EObject context, Constant_declaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.CONSTANT_DECLARATION__CONST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.CONSTANT_DECLARATION__CONST));
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.CONSTANT_DECLARATION__LEFT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.CONSTANT_DECLARATION__LEFT_EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConstant_declarationAccess().getConstMcsTypedNameParserRuleCall_1_0(), semanticObject.getConst());
		feeder.accept(grammarAccess.getConstant_declarationAccess().getLeft_exprExprParserRuleCall_3_0(), semanticObject.getLeft_expr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (telem?='T_Element' | tpack?='T_Package' | t_class?=Classifiers | t_inst?=Instances)
	 */
	protected void sequence_Element_type(EObject context, Element_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_EnumerationLiteral(EObject context, EnumerationLiteral semanticObject) {
		genericSequencer.createSequence(context, (EObject)semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=BooleanLiteral
	 */
	protected void sequence_Expression_term(EObject context, BoolExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.BOOL_EXPR__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.BOOL_EXPR__VAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getValBooleanLiteralParserRuleCall_7_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     builtin=BuiltInFnCall
	 */
	protected void sequence_Expression_term(EObject context, BuiltInFnCallExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.BUILT_IN_FN_CALL_EXPR__BUILTIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.BUILT_IN_FN_CALL_EXPR__BUILTIN));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getBuiltinBuiltInFnCallParserRuleCall_12_1_0(), semanticObject.getBuiltin());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     classifier=ComponentClassifierTerm
	 */
	protected void sequence_Expression_term(EObject context, CompExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.COMP_EXPR__CLASSIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.COMP_EXPR__CLASSIFIER));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getClassifierComponentClassifierTermParserRuleCall_2_1_0(), semanticObject.getClassifier());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {EmptySetExpr}
	 */
	protected void sequence_Expression_term(EObject context, EmptySetExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (map=Expression_term_FilterMapExpr_15_4_0_0 args+=Parameter+ filter=Expr?)
	 */
	protected void sequence_Expression_term(EObject context, FilterMapExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (list?='list' exp=Expr)
	 */
	protected void sequence_Expression_term_FilterMapExpr_15_4_0_0_SetExpr_15_4_1_0(EObject context, FilterSet semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.FILTER_SET__LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.FILTER_SET__LIST));
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.FILTER_SET__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.FILTER_SET__EXP));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getListListKeyword_15_1_0(), semanticObject.isList());
		feeder.accept(grammarAccess.getExpression_termAccess().getExpExprParserRuleCall_15_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     fn=FnCall
	 */
	protected void sequence_Expression_term(EObject context, FnCallExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.FN_CALL_EXPR__FN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.FN_CALL_EXPR__FN));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getFnFnCallParserRuleCall_13_1_0(), semanticObject.getFn());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (cond=Expr then=Expr else=Expr)
	 */
	protected void sequence_Expression_term(EObject context, IfThenElseExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.IF_THEN_ELSE_EXPR__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.IF_THEN_ELSE_EXPR__COND));
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.IF_THEN_ELSE_EXPR__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.IF_THEN_ELSE_EXPR__THEN));
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.IF_THEN_ELSE_EXPR__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.IF_THEN_ELSE_EXPR__ELSE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getCondExprParserRuleCall_10_2_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getExpression_termAccess().getThenExprParserRuleCall_10_4_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getExpression_termAccess().getElseExprParserRuleCall_10_6_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     val=IntegerTerm
	 */
	protected void sequence_Expression_term(EObject context, IntExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.INT_EXPR__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.INT_EXPR__VAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getValIntegerTermParserRuleCall_5_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (local=McsTypedName expr1=Expr expr2=Expr)
	 */
	protected void sequence_Expression_term(EObject context, LetExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.LET_EXPR__LOCAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.LET_EXPR__LOCAL));
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.LET_EXPR__EXPR1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.LET_EXPR__EXPR1));
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.LET_EXPR__EXPR2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.LET_EXPR__EXPR2));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getLocalMcsTypedNameParserRuleCall_18_2_0(), semanticObject.getLocal());
		feeder.accept(grammarAccess.getExpression_termAccess().getExpr1ExprParserRuleCall_18_4_0(), semanticObject.getExpr1());
		feeder.accept(grammarAccess.getExpression_termAccess().getExpr2ExprParserRuleCall_18_6_0(), semanticObject.getExpr2());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (expr1=Expr expr2=Expr)
	 */
	protected void sequence_Expression_term(EObject context, MappingExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.MAPPING_EXPR__EXPR1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.MAPPING_EXPR__EXPR1));
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.MAPPING_EXPR__EXPR2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.MAPPING_EXPR__EXPR2));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getExpr1ExprParserRuleCall_16_2_0(), semanticObject.getExpr1());
		feeder.accept(grammarAccess.getExpression_termAccess().getExpr2ExprParserRuleCall_16_4_0(), semanticObject.getExpr2());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     package=[AadlPackage|ID]
	 */
	protected void sequence_Expression_term(EObject context, PkgExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.PKG_EXPR__PACKAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.PKG_EXPR__PACKAGE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getPackageAadlPackageIDTerminalRuleCall_1_3_0_1(), semanticObject.getPackage());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((quant='forall' | quant='foreach' | quant='exists') args+=Parameter+ expr=Expr)
	 */
	protected void sequence_Expression_term(EObject context, QuantifiedExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=Range
	 */
	protected void sequence_Expression_term(EObject context, Range semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=RealTerm
	 */
	protected void sequence_Expression_term(EObject context, RealExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.REAL_EXPR__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.REAL_EXPR__VAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getValRealTermParserRuleCall_6_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     reference=RefTerm
	 */
	protected void sequence_Expression_term(EObject context, RefExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.REF_EXPR__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.REF_EXPR__REFERENCE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getReferenceRefTermParserRuleCall_3_1_0(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((exprs+=Expression_term_SetExpr_15_4_1_0 exprs+=Expr*) | exprs+=Expression_term_SetExpr_15_4_1_0)
	 */
	protected void sequence_Expression_term(EObject context, SetExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=StringTerm
	 */
	protected void sequence_Expression_term(EObject context, StringExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.STRING_EXPR__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.STRING_EXPR__VAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getValStringTermParserRuleCall_8_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     fn=Theorem_call
	 */
	protected void sequence_Expression_term(EObject context, TheoremCallExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.THEOREM_CALL_EXPR__FN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.THEOREM_CALL_EXPR__FN));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpression_termAccess().getFnTheorem_callParserRuleCall_14_1_0(), semanticObject.getFn());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (sub=NestedDotID?)
	 */
	protected void sequence_Expression_term(EObject context, ThisExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (fn=[Function|ID] (args+=Expr args+=Expr*)? newtype=Type_expression?)
	 */
	protected void sequence_FnCall(EObject context, FnCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type_expression expr=Expr)
	 */
	protected void sequence_FunctionBody(EObject context, FunctionBody semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.FUNCTION_BODY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.FUNCTION_BODY__TYPE));
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.FUNCTION_BODY__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.FUNCTION_BODY__EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFunctionBodyAccess().getTypeType_expressionParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFunctionBodyAccess().getExprExprParserRuleCall_4_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (args+=Parameter args+=Parameter*)? body=FunctionBody)
	 */
	protected void sequence_Function_declaration(EObject context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr=InstanceOfExpr_InstanceOfExpr_1_0_0_0 type=Type_expression)
	 */
	protected void sequence_InstanceOfExpr(EObject context, InstanceOfExpr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.INSTANCE_OF_EXPR__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.INSTANCE_OF_EXPR__EXPR));
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.INSTANCE_OF_EXPR__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.INSTANCE_OF_EXPR__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInstanceOfExprAccess().getInstanceOfExprExprAction_1_0_0_0(), semanticObject.getExpr());
		feeder.accept(grammarAccess.getInstanceOfExprAccess().getTypeType_expressionParserRuleCall_1_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (inst?='T_Instance' | t_inst_st?=t_instance_subtypes)
	 */
	protected void sequence_Instances(EObject context, Instances semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=SignedInt
	 */
	protected void sequence_IntegerLit(EObject context, IntegerLiteral semanticObject) {
		genericSequencer.createSequence(context, (EObject)semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (lowerBound=IntegerTerm | lowerBound=SignedConstant | lowerBound=ConstantValue) 
	 *         (upperBound=IntegerTerm | upperBound=SignedConstant | upperBound=ConstantValue)
	 *     )
	 */
	protected void sequence_IntegerRange(EObject context, IntegerRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=UnsignedInt unit=[UnitLiteral|ID]?)
	 */
	protected void sequence_IntegerTerm(EObject context, IntegerLiteral semanticObject) {
		genericSequencer.createSequence(context, (EObject)semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (root_type=Type_expression | root_type=Type_expression)
	 */
	protected void sequence_List_type(EObject context, List_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (types+=Type_declaration* constants+=Constant_declaration* functions+=Function_declaration* theorems+=Theorem_declaration*)
	 */
	protected void sequence_MCSAnnexLibrary(EObject context, MCSAnnexLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (calls+=Theorem_call?)
	 */
	protected void sequence_MCSAnnexSubclause(EObject context, MCSAnnexSubclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (importedUnit+=[ModelUnit|ID] importedUnit+=[ModelUnit|ID]*)+ 
	 *         (files+=File_name files+=File_name*)* 
	 *         types+=Type_declaration* 
	 *         constants+=Constant_declaration* 
	 *         functions+=Function_declaration* 
	 *         theorems+=Theorem_declaration* 
	 *         calls+=Theorem_call*
	 *     )
	 */
	protected void sequence_MCSFile(EObject context, MCSFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (lib=MCSAnnexLibrary | file=MCSFile | subclause=MCSAnnexSubclause)
	 */
	protected void sequence_MCSGrammarRoot(EObject context, MCSGrammarRoot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         root?='root' | 
	 *         iroot?='iroot' | 
	 *         nil?='nil' | 
	 *         empty?='empty' | 
	 *         allmodes?='allmodes' | 
	 *         typednameref=Mcs_name_ref
	 *     )
	 */
	protected void sequence_MCSNameExpr(EObject context, MCSNameExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (key=Type_expression val=Type_expression)
	 */
	protected void sequence_Mapping_type(EObject context, Mapping_type semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.MAPPING_TYPE__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.MAPPING_TYPE__KEY));
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.MAPPING_TYPE__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.MAPPING_TYPE__VAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMapping_typeAccess().getKeyType_expressionParserRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getMapping_typeAccess().getValType_expressionParserRuleCall_3_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (type=Type_expression | expr=Expr))
	 */
	protected void sequence_McsTypedName(EObject context, McsTypedName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (ref=[McsTypedName|ID] chain=MethodChain?)
	 */
	protected void sequence_Mcs_name_ref(EObject context, Mcs_name_ref semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((builtin+=BuiltInFnCall | method+=FnCall)*)
	 */
	protected void sequence_MethodChain(EObject context, MethodChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (base=[NamedElement|ID] sub=NestedDotID?)
	 */
	protected void sequence_NestedDotID(EObject context, NestedDotID semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     claim+=TextParm+
	 */
	protected void sequence_ParameterizedString(EObject context, ParameterizedString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (left=PlusExpr_BinaryExpr_1_0_0_0 (op='+' | op='-') right=TimesExpr) | 
	 *         (left=TimesExpr_BinaryExpr_1_0_0_0 (op='*' | op='/' | op='%') right=PrefixExpr) | 
	 *         (left=RelationalExpr_BinaryExpr_1_0_0_0 op=RelationalOp right=PlusExpr)
	 *     )
	 */
	protected void sequence_PlusExpr_RelationalExpr_TimesExpr(EObject context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (left=PlusExpr_BinaryExpr_1_0_0_0 (op='+' | op='-') right=TimesExpr) | 
	 *         (left=TimesExpr_BinaryExpr_1_0_0_0 (op='*' | op='/' | op='%') right=PrefixExpr)
	 *     )
	 */
	protected void sequence_PlusExpr_TimesExpr(EObject context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr=Expression_term newtype=Type_expression? chain=MethodChain?)
	 */
	protected void sequence_PostCastExpr(EObject context, PostCastExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((op='-' | op='not') expr=PrefixExpr)
	 */
	protected void sequence_PrefixExpr(EObject context, UnaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((lowerBound=IntegerTerm | lowerBound=RealTerm) (upperBound=IntegerTerm | upperBound=RealTerm))
	 */
	protected void sequence_Range(EObject context, Range semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=SignedReal
	 */
	protected void sequence_RealLit(EObject context, RealLiteral semanticObject) {
		genericSequencer.createSequence(context, (EObject)semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (lowerBound=RealTerm | lowerBound=SignedConstant | lowerBound=ConstantValue) 
	 *         (upperBound=RealTerm | upperBound=SignedConstant | upperBound=ConstantValue)
	 *     )
	 */
	protected void sequence_RealRange(EObject context, RealRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=UnsignedReal unit=[UnitLiteral|ID]?)
	 */
	protected void sequence_RealTerm(EObject context, RealLiteral semanticObject) {
		genericSequencer.createSequence(context, (EObject)semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (root?='root'? sub=NestedDotID)
	 */
	protected void sequence_RefTerm(EObject context, RefTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (root_type=Type_expression | root_type=Type_expression)
	 */
	protected void sequence_Set_type(EObject context, Set_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (t_ctype?='C_Type' | t_cimpl?='C_Impl' | t_fgclass?='C_Feature_Group' | t_annexclass?='C_Annex')
	 */
	protected void sequence_T_classifier_subtypes(EObject context, T_classifier_subtypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (textarg=MCSNameExpr unit=[UnitLiteral|ID]?)
	 */
	protected void sequence_TextParm(EObject context, ClaimArg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     str=StringTerm
	 */
	protected void sequence_TextParm(EObject context, ClaimString semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.CLAIM_STRING__STR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.CLAIM_STRING__STR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTextParmAccess().getStrStringTermParserRuleCall_0_1_0(), semanticObject.getStr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (string+=ParameterizedString+ expr=Expr)
	 */
	protected void sequence_TheoremBody(EObject context, TheoremBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (tname=[Theorem|ID] croot=Classifier_literal? (actarg+=Expr actarg+=Expr*)?)
	 */
	protected void sequence_Theorem_call(EObject context, TheoremCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID t_root?=Theorem_root? (args+=Parameter args+=Parameter*)? body=TheoremBody)
	 */
	protected void sequence_Theorem_declaration(EObject context, Theorem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (nilroot?='nil' | classifier=Classifiers)
	 */
	protected void sequence_Theorem_root(EObject context, Theorem_root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=TimesExpr_BinaryExpr_1_0_0_0 (op='*' | op='/' | op='%') right=PrefixExpr)
	 */
	protected void sequence_TimesExpr(EObject context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type_expression)
	 */
	protected void sequence_Type_declaration(EObject context, Type_declaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.TYPE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.TYPE_DECLARATION__NAME));
			if(transientValues.isValueTransient(semanticObject, McsPackage.Literals.TYPE_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, McsPackage.Literals.TYPE_DECLARATION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getType_declarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getType_declarationAccess().getTypeType_expressionParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (basic=Basic_type | composite=Composite_type | element=Element_type)
	 */
	protected void sequence_Type_expression(EObject context, Type_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (types+=Type_expression type+=Type_expression*)
	 */
	protected void sequence_Union_type(EObject context, Union_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID baseUnit=[UnitLiteral|ID] factor=NumberValue)
	 */
	protected void sequence_UnitLiteralConversion(EObject context, UnitLiteral semanticObject) {
		genericSequencer.createSequence(context, (EObject)semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_UnitLiteral(EObject context, UnitLiteral semanticObject) {
		genericSequencer.createSequence(context, (EObject)semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {AadlBoolean}
	 */
	protected void sequence_UnnamedBooleanType(EObject context, AadlBoolean semanticObject) {
		genericSequencer.createSequence(context, (EObject)semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (ownedLiteral+=EnumerationLiteral ownedLiteral+=EnumerationLiteral*)
	 */
	protected void sequence_UnnamedEnumerationType(EObject context, EnumerationType semanticObject) {
		genericSequencer.createSequence(context, (EObject)semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (range=IntegerRange? (ownedUnitsType=UnnamedUnitsType | referencedUnitsType=[UnitsType|QPREF])?)
	 */
	protected void sequence_UnnamedIntegerType(EObject context, UnnamedIntegerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (ownedNumberType=UnnamedIntegerType | ownedNumberType=UnnamedRealType | referencedNumberType=[NumberType|QPREF])
	 */
	protected void sequence_UnnamedRangeType(EObject context, UnnamedRangeType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (range=RealRange? (ownedUnitsType=UnnamedUnitsType | referencedUnitsType=[UnitsType|QPREF])?)
	 */
	protected void sequence_UnnamedRealType(EObject context, UnnamedRealType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {AadlString}
	 */
	protected void sequence_UnnamedStringType(EObject context, AadlString semanticObject) {
		genericSequencer.createSequence(context, (EObject)semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (ownedLiteral+=UnitLiteral ownedLiteral+=UnitLiteralConversion*)
	 */
	protected void sequence_UnnamedUnitsType(EObject context, UnitsType semanticObject) {
		genericSequencer.createSequence(context, (EObject)semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         t_access?='I_Access' | 
	 *         t_data_acc?='I_Data_Access' | 
	 *         t_sub_acc?='I_Subprogram_Access' | 
	 *         t_sub_gr_acc?='I_Subprogram_Group_Access' | 
	 *         t_bus_acc?='I_Bus_Access'
	 *     )
	 */
	protected void sequence_t_access_subtypes(EObject context, t_access_subtypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         t_annex_sub?='I_Component_Annex' | 
	 *         t_abstract?='I_Abstract' | 
	 *         t_sys?='I_System' | 
	 *         t_dev?='I_Device' | 
	 *         t_proc?='I_Processor' | 
	 *         t_virt_proc?='I_Virtual_Processor' | 
	 *         t_bus?='I_Bus' | 
	 *         t_vbus?='I_Virtual_Bus' | 
	 *         t_mem?='I_Memory' | 
	 *         t_proc?='I_Process' | 
	 *         t_tg?='I_Thread_Group' | 
	 *         t_t?='I_Thread' | 
	 *         t_d?='I_Data' | 
	 *         t_subprog?='I_Subprogram' | 
	 *         t_subprog_g?='I_Subprogram_Group'
	 *     )
	 */
	protected void sequence_t_component_subtypes(EObject context, t_component_subtypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         t_conn?='I_Connection' | 
	 *         t_feat_conn?='I_Feature_Connection' | 
	 *         t_port_conn?='I_Port_Connection' | 
	 *         t_parm_conn?='I_Parameter_Connection' | 
	 *         t_acc_con?='I_Access_Connection' | 
	 *         t_fg_conn?='I_Feature_Group_Connection'
	 *     )
	 */
	protected void sequence_t_connection_subtypes(EObject context, t_connection_subtypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (t_feat?='I_Feature' | t_abs_feat?='I_Abstract_Feature' | t_parm?='I_Parameter' | t_fg?='I_Feature_Group')
	 */
	protected void sequence_t_feature_subtypes(EObject context, t_feature_subtypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (t_f_i?='I_Flow_Impl' | t_f_i_source?='I_Flow_Impl_Source' | t_f_i_sink?='I_Flow_Impl_Sink' | t_f_i_path?='I_Flow_Impl_Path')
	 */
	protected void sequence_t_flow_impl_subtypes(EObject context, t_flow_impl_subtypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (t_f_spec?='I_Flow_Spec' | t_f_spec_source?='I_Flow_Spec_Source' | t_f_spec_sink?='I_Flow_Spec_Sink' | t_f_spec_path?='I_Flow_Spec_Path')
	 */
	protected void sequence_t_flow_spec_subtypes(EObject context, t_flow_spec_subtypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         t_subc_st?=t_subcomponent_subtypes | 
	 *         t_sbcall?='I_Subprogram_Call' | 
	 *         t_callseq?='I_Call_Sequence' | 
	 *         t_eeflow?='I_End_To_End_Flow' | 
	 *         t_proto?='I_Prototype' | 
	 *         t_mode?='I_Mode' | 
	 *         t_mod_trans?='I_Mode_Transition' | 
	 *         t_mode_trig?='I_Mode_Trigger_Id'
	 *     )
	 */
	protected void sequence_t_instance_subtypes(EObject context, t_instance_subtypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (t_port?='I_Port' | t_d_port?='I_Data_Port' | t_ev_port?='I_Event_Port' | t_evd_port?='I_Event_Data_Port')
	 */
	protected void sequence_t_port_subtypes(EObject context, t_port_subtypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (t_sub?='I_Component' | t_cimpl_st?=t_component_subtypes)
	 */
	protected void sequence_t_subcomponent_subtypes(EObject context, t_subcomponent_subtypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
